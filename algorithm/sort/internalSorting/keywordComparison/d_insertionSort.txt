/// this is a  topic about insertion sort ///
插入排序 <==> insertion sort 

实例：减而治之
    迭代轮次            前缀有序序列          当前元素            后缀无序序列
    -1                 ^                    ^                  5 2 7 4 6 3 1
    0                  ^                    5                    2 7 4 6 3 1
    1                  (5)                  2                      7 4 6 3 1
    2                  (2) 5                7                        4 6 3 1
    3                  2 5 (7)              4                          6 3 1
    4                  2 (4) 5 7            6                            3 1
    5                  2 4 5 (6) 7          3                              1
    6                  2 (3) 4 5 6 7        1                              ^
    7                  (1) 2 3 4 5 6 7      ^                              ^
    

实现：
    /// 对列表中起始于位置p的连续n个元素做插入排序，valid(p) && rank(p) + n <= size
    template <typename T> void List<T>::insertionSort(ListNodePosi<T> p, int n) { ///< 对区间[p, p+n)中的元素进行插入排序
        for (int r = 0; r < n; r++) { ///< 循环变量r是已经排序的前缀有序序列的长度，起始是0；逐一引入各节点，有Sr得到Sr+1，Sr+1是Sr相邻的下一个节点 
            insert ( search ( p->data, r, p ), p->data ); ///< 其后插入p->data节点；search ( p->data, r, p )语义：在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者。即在区间[p-r, p)查找p->data，返回不大于p->data的最靠后的位置
            p = p->succ; remove(p->pred); ///< 后缀无序序列 转向下一节点
            } ///< n次迭代，每次O(r+1)
        } ///< 仅使用O(1)的辅助空间，属于就地算法
    
    /// insert、remove implementation in selection sort file
    /// search implementation 
    template <typename T> ListNodePosi<T> List<T>::search ( T const& e, int n, ListNodePosi<T> p ) const { ///< 在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者
        // assert: 0 <= n <= rank(p) < _size
        /*DSA*/printf ( "searching for " ); print ( e ); printf ( " :\n" );
        do {
            p = p->pred; n--;  ///< 从右向左
            /*DSA*/  printf ( " -->%4d", p->data );
        } while ( ( -1 < n ) && ( e < p->data ) ); ///< 逐个比较，直至命中或越界
        /*DSA*/  printf ( "\n" );
        return p; ///< 返回查找终止的位置
        } ///< 失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否

算法时间：性能
    最好情况：
        完全（或几乎）有序
        每次迭代，只需1次比较，0次交换
        累计O(n)时间
    
    最坏情况：
        完全（或几乎）逆序
        每次迭代，需要r+1次比较，1次交换；r是第几次迭代或有序子序列长度
            你可能会想？若使用Vector对有序子序列进行二分查找，比较次数从r-1次降到log2(r-1)次是不是会更快呢？
            实则不然，每次迭代，需要log2(r-1)次比较，r-1次移动，而得不偿失（比较总比移动快）
        累计O(n^2)时间
        
