/// this is a  topic about insertion sort ///
插入排序 <==> insertion sort 

实例：减而治之
    迭代轮次            前缀有序序列          当前元素            后缀无序序列
    -1                 ^                    ^                  5 2 7 4 6 3 1
    0                  ^                    5                    2 7 4 6 3 1
    1                  (5)                  2                      7 4 6 3 1
    2                  (2) 5                7                        4 6 3 1
    3                  2 5 (7)              4                          6 3 1
    4                  2 (4) 5 7            6                            3 1
    5                  2 4 5 (6) 7          3                              1
    6                  2 (3) 4 5 6 7        1                              ^
    7                  (1) 2 3 4 5 6 7      ^                              ^
    

实现：
    /// 对列表中起始于位置p的连续n个元素做插入排序，valid(p) && rank(p) + n <= size
    template <typename T> void List<T>::insertionSort(ListNodePosi<T> p, int n) { ///< 对区间[p, p+n)中的元素进行插入排序
        for (int r = 0; r < n; r++) { ///< 循环变量r是已经排序的前缀有序序列的长度，起始是0；逐一引入各节点，有Sr得到Sr+1，Sr+1是Sr相邻的下一个节点 
            insert ( search ( p->data, r, p ), p->data ); ///< 其后插入p->data节点；search ( p->data, r, p )语义：在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者。即在区间[p-r, p)查找p->data，返回不大于p->data的最靠后的位置
            p = p->succ; remove(p->pred); ///< 后缀无序序列 转向下一节点
            } ///< n次迭代，每次O(r+1)
        } ///< 仅使用O(1)的辅助空间，属于就地算法
    
    /// insert、remove implementation in selection sort file
    /// search implementation 
    template <typename T> ListNodePosi<T> List<T>::search ( T const& e, int n, ListNodePosi<T> p ) const { ///< 在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者
        // assert: 0 <= n <= rank(p) < _size
        /*DSA*/printf ( "searching for " ); print ( e ); printf ( " :\n" );
        do {
            p = p->pred; n--;  ///< 从右向左
            /*DSA*/  printf ( " -->%4d", p->data );
        } while ( ( -1 < n ) && ( e < p->data ) ); ///< 逐个比较，直至命中或越界
        /*DSA*/  printf ( "\n" );
        return p; ///< 返回查找终止的位置
        } ///< 失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否

算法时间：性能
    最好情况：
        完全（或几乎）有序
        每次迭代，只需1次比较
        累计O(n)时间
    
    最坏情况：
        完全（或几乎）逆序
        每次迭代，需要r次比较；r是第几次迭代或有序子序列长度
            你可能会想？若使用Vector对有序子序列进行二分查找，比较次数从r次降到log2(r)次是不是会更快呢？
            实则不然，每次迭代，需要log2(r)次比较，r次移动，而得不偿失（比较总比移动快）
        累计O(n^2)时间
    
    平均时间：
        假定：各元素的取值遵守 均匀、对立分布。
        于是：平均要做多少次元素比较？
        
        考查：L[r]刚插入完成的那一时刻（穿越？）<==>等价于有序前缀的长度刚刚增长到r+1的时刻。
        试问：此时的有序前缀L[0, r]中，哪个元素是此前刚刚插入的L[r]元素呢？
                这是随机的，不知道。
             此前过程中，插入L[r]进行了多少次元素比较呢？
                这是随机的，不知道。
        
        此时，我们需要猜一下，现在在场的每一位/个同学/元素，都应该有均等的概率作为最后的同学/元素来到这个课堂/插入到有序前缀序列中来。
        
        观察：其中的r+1个元素均有可能，且概率均等于1/(r+1) <==> 元素值均匀、独立分布
        因此，在刚完成的这次迭代中，为引入S[r]所花费时间的数学期望为：
            [r + (r-1) + ... + 3 + 2 + 1 + 0] / (r + 1) + 1 = r/2 + 1
                                                          ^
                                                          | 是转向下一节点的时间花费
        
        于是，总体时间的数学期望为：
            Sn = ( a0 + an ) * n/2 = (1 + n/2 + 1) * n/2 = ( 2n + n^2 / 2 ) / 2 = n + n^2 / 4
               = O(n^2)
               
       
        
        
        
        
