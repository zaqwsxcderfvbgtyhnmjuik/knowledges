/// this is a  topic about insertion sort ///
插入排序 <==> insertion sort 

实例：减而治之
    迭代轮次            前缀有序序列          当前元素            后缀无序序列
    -1                 ^                    ^                  5 2 7 4 6 3 1
    0                  ^                    5                    2 7 4 6 3 1
    1                  (5)                  2                      7 4 6 3 1
    2                  (2) 5                7                        4 6 3 1
    3                  2 5 (7)              4                          6 3 1
    4                  2 (4) 5 7            6                            3 1
    5                  2 4 5 (6) 7          3                              1
    6                  2 (3) 4 5 6 7        1                              ^
    7                  (1) 2 3 4 5 6 7      ^                              ^
    

实现：
    /// 对列表中起始于位置p的连续n个元素做插入排序，valid(p) && rank(p) + n <= size
    template <typename T> void List<T>::insertionSort(ListNodePosi<T> p, int n) { ///< 对区间[p, p+n)中的元素进行插入排序
        for (int r = 0; r < n; r++) { ///< 循环变量r是已经排序的前缀有序序列的长度，起始是0；逐一引入各节点，有Sr得到Sr+1，Sr+1是Sr相邻的下一个节点 
            insert ( search ( p->data, r, p ), p->data ); ///< 其后插入p->data节点；search ( p->data, r, p )语义：在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者。即在区间[p-r, p)查找p->data，返回不大于p->data的最靠后的位置
            p = p->succ; remove(p->pred); ///< 后缀无序序列 转向下一节点
            } ///< n次迭代，每次O(r+1)
        } ///< 仅使用O(1)的辅助空间，属于就地算法
    
    /// insert、remove implementation in selection sort file
    /// search implementation 
    template <typename T> ListNodePosi<T> List<T>::search ( T const& e, int n, ListNodePosi<T> p ) const { ///< 在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者
        // assert: 0 <= n <= rank(p) < _size
        /*DSA*/printf ( "searching for " ); print ( e ); printf ( " :\n" );
        do {
            p = p->pred; n--;  ///< 从右向左
            /*DSA*/  printf ( " -->%4d", p->data );
        } while ( ( -1 < n ) && ( e < p->data ) ); ///< 逐个比较，直至命中或越界
        /*DSA*/  printf ( "\n" );
        return p; ///< 返回查找终止的位置
        } ///< 失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否

算法时间：性能
    最好情况：
        完全（或几乎）有序
        每次迭代，只需1次比较
        累计O(n)时间
    
    最坏情况：
        完全（或几乎）逆序
        每次迭代，需要r次比较；r是第几次迭代或有序子序列长度
            你可能会想？若使用Vector对有序子序列进行二分查找，比较次数从r次降到log2(r)次是不是会更快呢？
            实则不然，每次迭代，需要log2(r)次比较，r次移动，而得不偿失（比较总比移动快）
        累计O(n^2)时间
    
    平均时间：
        假定：各元素的取值遵守 均匀、对立分布。
        于是：平均要做多少次元素比较？
        
        考查：L[r]刚插入完成的那一时刻（穿越？）<==>等价于有序前缀的长度刚刚增长到r+1的时刻。
        试问：此时的有序前缀L[0, r]中，哪个元素是此前刚刚插入的L[r]元素呢？
                这是随机的，不知道。
             此前过程中，插入L[r]进行了多少次元素比较呢？
                这是随机的，不知道。
        
        此时，我们需要猜一下，现在在场的每一位/个同学/元素，都应该有均等的概率作为最后的同学/元素来到这个课堂/插入到有序前缀序列中来。
        
        观察：其中的r+1个元素均有可能，且概率均等于1/(r+1) <==> 元素值均匀、独立分布
        因此，在刚完成的这次迭代中，为引入S[r]所花费时间的数学期望为：
            [r + (r-1) + ... + 3 + 2 + 1 + 0] / (r + 1) + 1 = r/2 + 1
                                                          ^
                                                          | 是转向下一节点的时间花费
        
        于是，总体时间的数学期望为：
            Sn = ( a0 + an ) * n/2 = (1 + n/2 + 1) * n/2 = ( 2n + n^2 / 2 ) / 2 = n + n^2 / 4
               = O(n^2)
         
补充：
    重要概念：
        逆序对 <==> inversion pair：
            对于一个包含N个非负整数的数组A[1..n]，如果有i < j，且A[ i ]>A[ j ]，则称(A[ i] ,A[ j] )为数组A中的一个逆序对。
            例如，数组（3，1，4，5，2）的逆序对有(3,1),(3,2),(4,2),(5,2)，共4个。
        
        逆序数组逆序对个数：
            考虑一个n（n>1）个元素的数组如下：
                B[1..n] = {n, n-1, n-2, ..., 3, 2, 1}
            则逆序对个数为：
                技巧：若元素a,b是一个逆序对，将逆序对的数量同b元素绑定在一起，即此时a的逆序对数是0，b的逆序对数是1；记为i(a)=0, i(b)=1, 则整个数组B的逆序对为I=i(B[1]) + ... + i(B[n])
                结合技巧观察逆序数组B可得：
                    i(B[1]) = 0；
                    i(B[2]) = 1；
                    i(B[3]) = 2；
                    ...
                    i(B[n]) = n-1;
                于是数组B的逆序对个数为：
                    I=(0 + n-1) / 2 * n = n*(n - 1)/2   ///< 等差数列求和公式
                     = C(n,2)       ///< 组合数：从n中选取2个元素的组合数
                     = n*(n-1)/2!
                     = n*(n-1)/2
    
    逆序对与插入排序：
        1) 在将元素p插入到前缀有序子序列时，元素p有几个逆序对，则将进行几次比较（证明先略过，逆序数组时，清晰可见；杂序数组时，清晰可见）。这是插入排序复杂度的本质。   
        2) 另外一部分则是将元素进行插入的复杂度，每个元素1时间,n个元素n时间。
        3) 于是整个数组插入排序完成时，共进行了I次比较和n次插入，则O(n) = I + n
            数组有序时，I=0，即最优复杂度为O(n)
            数组逆序时，I是O(n^2)量级，即最坏复杂度为O(n^2)
        4) 于是插入排序的复杂度不是问题规模本身，而是输入数据的逆序对数量这个特性决定的，因此称之为输入敏感型排序算法——input sensitive sort，与其他算法相比，显得非常独特。
            
            
        
    
       
        
        
        
        
