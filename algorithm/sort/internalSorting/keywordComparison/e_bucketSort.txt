/// this is a topic about bucket sort

背景：
    作为散列思想的一个具体应用实例，即桶排序和计数排序算法；
    这类算法的性能，已经不在完全取决于输入元素的规模，也就是待排序序列的长度n，同时也取决于待排序元素的取值范围M,
    事实上，这类新算法的渐进时间复杂度将是O( max(n, M) )，因此待排序元素的取值范围越是有限，这种算法的优势越是明显，在很多应用中，元素的范围都会不超过元素的规模，意味着存在大量的元素的重复，比如高考成绩排序。
    而若果真如此，这类新算法就有望在线性时间O(n)内，完成排序。
    
简单情况
    考查如下问题：给定[0, M)内的n个互异整数[n, M），如何高效地对其排序？
        自然，向量排序器或列表排序器中的任一排序算法，均可完成这一任务。但CBA式（Classification base of Association）排序算法注定在最坏情况下需要O(nlogn)时间。
        实际上，针对数值类型和取值范围特定的这一具体问题，完全可在更短的时间内完成排序。
        为此，引入长度为M的散列表。比如下图，即为取M = 10和n = 5的一个实例：
                    2   3       5           8   9   <--待排序数据
            0   0   1   1   0   1   0   0   1   1   <--散列表value
            0   1   2   3   4   5   6   7   8   9   <--散列表key
                
        接下来，使用最简单的散列函数hash(key) = key，将这些整数视作关键码并逐一插入散列表中。最后，顺序遍历一趟该散列表，依次输出非空桶中存放的关键码，即可得到原整数集合的排序结果。
    该算法借助一组桶单元实现对一组关键码的分拣，故称作桶排序（bucketsort）。
    该算法所用散列表共占O(M)空间。散列表的创建和初始化耗时O(M)，将所有关键码插入散列表耗时O(n)，依次读出非空桶中的关键码耗时O(M)，故总体运行时间为O(n + M)。

一般情况
    若将上述问题进一步推广：若允许输入整数重复，又该如何高效地实现排序？
                    2c
                    2b                          9b
                    2a  3       5               9a  <--待排序数据
            0   0   3   1   0   1   0   0   0   1   <--散列表value
            0   1   2   3   4   5   6   7   8   9   <--散列表key
                    ↓   ↓       ↓               ↓   <--独立链                                
                    2a  3       5               9a
                    ↓   ↓       NULL            ↓
                    2b  NULL                    9b
                    ↓                           ↓
                    2c                          NULL    
                    ↓
                    NULL
    依然可以沿用以上构思，只不过这次需要处理散列冲突。具体地上图所示，不妨采用 独立链法排解冲突。
    在将所有整数作为关键码插入散列表之后，只需一趟顺序遍历将各非空桶中的独立链依次串接起来，即可得到完整的排序结果。
    而且只要在串联时留意链表方向，甚至可以确保排序结果的稳定，故如此实现的桶排序算法属于稳定算法。

算法实现：
    以后实现，先略。































































