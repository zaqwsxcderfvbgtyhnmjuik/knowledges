/// this is a topic about quick sort ///

背景
    C.A.R Hoare 1960年代发明的一种算法
    
分而治之
    将序列分为两个子序列：S = SL + SR ///< O(n)
        规模缩小：max { |SL|, |SR| } < n     ///< 左右两子序列的长度小于原始规模 n
        彼此独立：max ( SL ) <= max ( SR )   ///< 左子序列中的最大者 小于等于 右子序列的最小者，即前一序列中的任意元素都不得超过后一序列的任意元素
    在子序列分别递归地排序之后，原序列自然有序
        sorted(S) = sorted(SL) + sorted(SR)
    平凡解
        只剩单个元素时，本身就是解
    
    mergesort的计算量和难点在于合，而quicksort的难点在于分

轴点
    pivot:随机或任意选取的一个元素的值的大小，不是某个固定位置上的元素，是一个元素数值，或者说其位置在过程中不确定，一趟排序完成后才能确定
        左/右侧的元素，均不比它更大/小
    
    以轴点pivot为界，原序列的划分自然实现：
        [lo, hi) = [lo, mi) + [mi, mi+1) + [mi+1, hi)
        
实现
    template <typename T> void Vector<T>::quickSort(Rank lo, Rank hi) {
        if ( hi - lo < 2) return; ///< 单元素区间自然有序，否则
        
        Rank mi = partition ( lo, hi - 1); ///< 先构造轴点，再
        quickSort(lo, mi);   ///< 前缀排序
        quickSort(mi+1, hi); ///< 后缀排序
        }
        
    可以看出，快排的核心在于如何快速的确定轴点
    template <typename T> ///< 轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩
        Rank Vector<T>::partition ( Rank lo, Rank hi ) { ///< DUP版：可优化处理多个关键码雷同的退化情况
        swap ( _elem[lo], _elem[ lo + rand() % ( hi - lo ) ] ); ///< 任选一个元素与首元素交换
        hi--; T pivot = _elem[lo]; ///< 以首元素为候选轴点——经以上交换，等效于随机选取
        while ( lo < hi ) { ///< 从向量的两端交替地向中间扫描
            while ( lo < hi )
                if ( pivot < _elem[hi] ) ///< 在大于pivot的前提下
                    hi--; ///< 向左拓展右端子向量
                else //直至遇到不大于pivot者
                    { _elem[lo++] = _elem[hi]; break; } ///< 将其归入左端子向量
            while ( lo < hi )
                if ( _elem[lo] < pivot ) ///< 在小于pivot的前提下
                    lo++; ///< 向右拓展左端子向量
                else //直至遇到不小于pivot者
                    { _elem[hi--] = _elem[lo]; break; } ///< 将其归入右端子向量
        } ///< assert: lo == hi
        _elem[lo] = pivot; ///< 将备份的轴点记录置于前、后子向量之间
        return lo; ///< 返回轴点的秩
        } 
        
轴点：续
    坏消息：--》在原始序列中，轴点未必存在...
    必要条件：--》轴点必定已然就位 ///< 尽管反之不然
    derangement sequence:--》2 3 4 5 6 ... n 1
    特别地：--》在有序序列中，所有元素皆为轴点；反之亦然
    快速排序：--》就是将所有元素逐个转换为轴点的过程
    好消息：--》通过适当交换，可使任一元素转换为轴点
    问题：--》如何交换，成本多高？


构造轴点
    1) 选取U子序列的第一个元素[lo]，并备份其值pivot，将其构造成轴点；
                    lo                                         hi         
            L <=    pivot <= G      <--       L <= pivot   U   pivot <= G 
                    hi                                  lo               
    2) 原则：L <= pivot <= G; U = [lo, hi]中, [lo]和[hi]交替空闲；构造过程中，子序列L或G长度单调不减；U子序列长度单调减。
        a. 接第一步，左侧[lo]值被取出，此时左侧[lo]空闲；于是尝试将G子序列向左侧拓展，直到遇到元素x小于pivot，将元素x赋值给左侧空闲[lo]，相当于被取出来了；
        b. 接上一步，右侧[hi]值被取出，此时右侧[hi]空闲；于是尝试将L子序列向右侧拓展，直到遇到元素x大于pivot，将元素x赋值给右侧空闲[lo]，相当于被取出来了；
        c. 循环往复，直到lo=hi，将轴点值pivot，赋值给[lo]或[hi]
    
    3) 复杂度分析
        不稳定：lo/hi的移动方向相反，左/右侧的大/小重复元素可能前/后颠倒
        空间复杂度：只需要O(1)辅助空间
        时间复杂度：
            最好情况：每次划分都(接近)平均，轴点总是(接近)中央
                T(n) = 2xT( (n-1)/2 ) + O(n) = O(nlogn) ///< 抵达下界
            最坏情况：每次划分都极不均衡，比如，轴点总是最大/小元素
                T(n) = T( n-1 ) + T(0) + O(n) = O(n^2) ///< 与冒泡排序相当
                ※即便采取随机选取、三者取中（选取三个元素，取中间值作为轴点）等之类策略，也只能降低最坏情况的概率，而无法杜绝。
            平均情况：以均匀独立分布为例
            
                
                
            
        
        
