/// this is a topic about quick sort ///

背景
    C.A.R Hoare 1960年代发明的一种算法
    
分而治之
    将序列分为两个子序列：S = SL + SR ///< O(n)
        规模缩小：max { |SL|, |SR| } < n     ///< 左右两子序列的长度小于原始规模 n
        彼此独立：max ( SL ) <= max ( SR )   ///< 左子序列中的最大者 小于等于 右子序列的最小者，即前一序列中的任意元素都不得超过后一序列的任意元素
    在子序列分别递归地排序之后，原序列自然有序
        sorted(S) = sorted(SL) + sorted(SR)
    平凡解
        只剩单个元素时，本身就是解
    
    mergesort的计算量和难点在于合，而quicksort的难点在于分

轴点
    pivot:随机或任意选取的一个元素的值的大小，不是某个固定位置上的元素，是一个元素数值，或者说其位置在过程中不确定，一趟排序完成后才能确定
        左/右侧的元素，均不比它更大/小
    
    以轴点pivot为界，原序列的划分自然实现：
        [lo, hi) = [lo, mi) + [mi, mi+1) + [mi+1, hi)
        
实现
    template <typename T> void Vector<T>::quickSort(Rank lo, Rank hi) {
        if ( hi - lo < 2) return; ///< 单元素区间自然有序，否则
        
        Rank mi = partition ( lo, hi - 1); ///< 先构造轴点，再
        quickSort(lo, mi);   ///< 前缀排序
        quickSort(mi+1, hi); ///< 后缀排序
        }
        
    可以看出，快排的核心在于如何快速的确定轴点
    template <typename T> ///< 轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩
        Rank Vector<T>::partition ( Rank lo, Rank hi ) { ///< DUP版：可优化处理多个关键码雷同的退化情况
        swap ( _elem[lo], _elem[ lo + rand() % ( hi - lo ) ] ); ///< 任选一个元素与首元素交换
        hi--; T pivot = _elem[lo]; ///< 以首元素为候选轴点——经以上交换，等效于随机选取
        while ( lo < hi ) { ///< 从向量的两端交替地向中间扫描
            while ( lo < hi )
                if ( pivot < _elem[hi] ) ///< 在大于pivot的前提下
                    hi--; ///< 向左拓展右端子向量
                else //直至遇到不大于pivot者
                    { _elem[lo++] = _elem[hi]; break; } ///< 将其归入左端子向量
            while ( lo < hi )
                if ( _elem[lo] < pivot ) ///< 在小于pivot的前提下
                    lo++; ///< 向右拓展左端子向量
                else //直至遇到不小于pivot者
                    { _elem[hi--] = _elem[lo]; break; } ///< 将其归入右端子向量
        } ///< assert: lo == hi
        _elem[lo] = pivot; ///< 将备份的轴点记录置于前、后子向量之间
        return lo; ///< 返回轴点的秩
        } 
        
轴点：续
    坏消息：--》在原始序列中，轴点未必存在...
    必要条件：--》轴点必定已然就位 ///< 尽管反之不然
    derangement sequence:--》2 3 4 5 6 ... n 1
    特别地：--》在有序序列中，所有元素皆为轴点；反之亦然
    快速排序：--》就是将所有元素逐个转换为轴点的过程
    好消息：--》通过适当交换，可使任一元素转换为轴点
    问题：--》如何交换，成本多高？


构造轴点
    1) 选取U子序列的第一个元素[lo]，并备份其值pivot，将其构造成轴点；
                    lo                                         hi         
            L <=    pivot <= G      <--       L <= pivot   U   pivot <= G 
                    hi                                  lo               
    2) 原则：L <= pivot <= G; U = [lo, hi]中, [lo]和[hi]交替空闲；构造过程中，子序列L或G长度单调不减；U子序列长度单调减。
        a. 接第一步，左侧[lo]值被取出，此时左侧[lo]空闲；于是尝试将G子序列向左侧拓展，直到遇到元素x小于pivot，将元素x赋值给左侧空闲[lo]，相当于被取出来了；
        b. 接上一步，右侧[hi]值被取出，此时右侧[hi]空闲；于是尝试将L子序列向右侧拓展，直到遇到元素x大于pivot，将元素x赋值给右侧空闲[lo]，相当于被取出来了；
        c. 循环往复，直到lo=hi，将轴点值pivot，赋值给[lo]或[hi]
    
    3) 复杂度分析
        不稳定：lo/hi的移动方向相反，左/右侧的大/小重复元素可能前/后颠倒
        空间复杂度：只需要O(1)辅助空间
        时间复杂度：
            最好情况：每次划分都(接近)平均，轴点总是(接近)中央
                T(n) = 2xT( (n-1)/2 ) + O(n) = O(nlogn) ///< 抵达下界
            最坏情况：每次划分都极不均衡，比如，轴点总是最大/小元素
                T(n) = T( n-1 ) + T(0) + O(n) = O(n^2) ///< 与冒泡排序相当
                ※即便采取随机选取、三者取中（选取三个元素，取中间值作为轴点）等之类策略，也只能降低最坏情况的概率，而无法杜绝。
            平均情况：以均匀独立分布为例<==>精确估计
                考查任何一个这样的随机序列，调用partition算法会有几种可能呢？无非n种可能。
                具体是哪一种情况完全取决于最初所选定的那个候选轴点，更准确的讲是候选轴点在最终有序序列中所具有的秩k, k = 0,1,2 , ... , n-2, n-1
                partition算法输出的子序列L长度也应该是k，这个子序列对应的那个子任务所需的平均运行时间也因此就可以表示为T(k)
                对称的，partition算法所输出的子序列G长度应该为n-k-1，这个子序列对应的那个子任务从递归的角度看所需的平均运行时间也因此可以表示为T(n-k-1)
                这样一对排序子任务总共所需要的运行时间也自然就是二者之和
                进一步的，既然这里是按照均匀独立分布，因此k值各种情况的出现的概率应该均等。具体来说都是1/n。
                因此所有这些情况所对应的平均运行时间，也就是这个概率对它们的总和进行平均，即：
                (1/n) x ∑<k=0, k=n-1> [ T(k) + T(n-k-1) ] ///< ∑<k=0, k=n-1> [ f(k) ] = f(0) + f(1) + ... + f(n-2) + f(n-1)
                稍加观察，不难发现求和序列∑<k=0, k=n-1> [ T(k) ] 和求和序列∑<k=0, k=n-1> [ T(n-k-1) ] 的求和结果应该是完全相等的，原因是这两个求和序列的范围k都是从0到n-1，只不过前者从0到n-1递增，后者从n-1到0递减
                因此只需保留其中的一项，同时作为补偿。将它的系数加倍，即：
                (2/n) x ∑<k=0, k=n-1> [ T(k) ]
                秩为k的候选轴点成为真正的轴点需要n时间，即lo=hi时，成为真正的轴点；再加上随机选出候选轴点的1时间，对该随机序列有如下迭代等式：
                T(n) = (n+1) + (2/n) x ∑<k=0, k=n-1> [ T(k) ] ⑴
                对该等式进行求解，对等式⑴的两边同时乘以n有：
                T(n) x n = (n+1) x n + 2 x ∑<k=0, k=n-1> [ T(k) ] ⑵
                将⑵中的n都替换为n-1得下面等式：
                T(n-1) x (n-1) = (n-1) x n + 2 x ∑<k=0, k=n-2> [ T(k) ] ⑶
                现在将等式⑵和⑶相减有这样一个等式：
                T(n) x n - T(n-1) x (n-1) = 2 x n + 2 x T(n-1)⑷
                对T(n)和T(n-1)合并同类项有：
                T(n) x n - T(n-1) x (n+1) = 2 x n ⑸
                对⑸等式两边同时除以n x (n+1)有：
                T(n)/(n+1) = 2/(n+1) + T(n-1)/n ⑹
                此时将⑹的T(n)/(n+1)视为S(n)，那么T(n-1)/n为S(n-1)，于是就有了关于S(n)的简明递推式，因此接下来进而将右侧的S(n-1)替换为S(n-2)，为此需追加一项2/n，如下：
                T(n)/(n+1) = 2/(n+1) + 2/n + T(n-2)/(n-1) ⑺
                这种替换可以持续下去，有：
                T(n)/(n+1) = 2/(n+1) + 2/n + 2/(n-1) + 2/(n-2) + ... + 2/2 + T(0)/1 ⑻
                等式⑻的右侧是一个调和级数，同ln(n)同阶，利用ln(n) = 2 x ln(2) x log2(n)等式，于是有：
                T(n)/(n+1) = 2 x ln(2) x log2(n) ⑼
                等式⑼两侧同时乘以n+1，于是有：
                T(n) = 2 x ln(2) x (n + 1) x log(n) ⑽
                     = 1.39 x (n + 1) x log(n)
                这样小的一个常系数，也保证了快速排序算法在通常情况下的优异性能，也就是说快速排序，的确名副其实。
            
                
                
            
        
        
