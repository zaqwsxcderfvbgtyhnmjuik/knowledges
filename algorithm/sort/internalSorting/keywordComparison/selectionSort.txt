/// this is a topic about selection sort ///
选择排序 <==> selection sort

实例：
    迭代轮次        前缀无序子序列             后缀有序子序列
    0              5 2 7max 4 6 3 1                      ^                                                                                         
    1              5 2 4 6max 3 1                        7                                                                                 
    2              5max 2 4 3 1                        6 7                                                                                                     
    3              2 4max 3 1                        5 6 7                                                                                 
    4              2 3max 1                        4 5 6 7                                                                         
    5              2max 1                        3 4 5 6 7                                                                             
    6              1max                        2 3 4 5 6 7                                                                                             
    7              ^                         1 2 3 4 5 6 7
    
代码实现：
    /// 对列表中起始于位置p（包括p在内的n个元素）的连续n个元素做选择排序，即待排序区间为[p, p+n)；valid(p) && rank(p) + n <= size
    template <typename T> void List<T>::selectionSort(Posi(T) p, int n) { 
        Posi(T) head = p->pred; Posi(T) tail = p; ///< 待排序区间(head, tail)，为开区间
        for (int i = 0; i < n; i++) tail = tail->succ; ///< head、tail可能是头、尾哨兵
        while ( 1 < n ) { ///< 反复从（非平凡的）待排序区间内找出最大者，并移至有序区间前端
            insertBefore ( tail, remove ( selectMax ( head->succ, n ) ) );  ///< selectMax(head->succ, n ) 从区间[head->succ, head->succ + n)中找出节点最大者，若有多个最大者，选最靠后的最大者
            tail = tail->pred; n--; ///< 待排序区间、有序区间的范围，均同步更新
            }
        }
        注:
            succ <==> successor node <==> 后继节点
            pred <==> predecessor node <==> 前驱节点
                
        推敲：
            insertBefore(,)与remove()分别涉及到new和delete操作，new和delete通常是基本操作的100倍，也就是高出2个数量级
            
算法时间：性能
    共迭代n次，在第k次迭代中
        selectMax()为O(n-k)
        remove()和insertBefore()均是O(1)
    故总体复杂度应为O(n^2)<==最好、最坏、平均亦是如此
    
    尽管如此，元素移动操作远远少于冒泡排序，由冒泡排序的移动n次降为选择排序的1次；也就是说，O(n^2)主要来自于元素的比较操作 ///< 成本相对冒泡更低
    
