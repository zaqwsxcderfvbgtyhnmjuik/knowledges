/// this is a topic about merge sort ///
// 背景
    当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要用到本章介绍的外部排序算法来解决。

// 外部排序算法由两个阶段构成
    1.按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；
        补充：此例中采用了将文件进行等分的操作，还有不等分的算法。
    2.对得到的顺段进行合并，直至得到整个有序的文件为止。
        补充：在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。
        
// 排序时间分析
    1.影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。
    2.一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：s=⌈ logk(⁡m) ⌉（其中 s 表示归并次数）。
      证明：
          未进行归并时，归并段为m个；进行1次归并后，归并段为⌈m/k⌉个，进行2次归并后，归并段为⌈⌈m/k⌉/k⌉个，以此类推...；
          利用夹逼定理容易得，对于k^(s-1) + 1到k^s个归并段，其归并的次数是一样的；于是对m进行放大放缩，使得m/k^s==1
          于是有
            m/k^s==1，
          进行对数变换有
            s=logk(m)
          若去除对m的放大放缩有
            s=⌈logk(m)⌉
          更符合一般的表达习惯有
            s=⌊logk(m)⌋ + 1; m/k^s < 1时

// 算法优化
    想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
      增加 k-路平衡归并中的 k 值；
          即多路平衡归并算法
      尽量减少初始归并段的数量 m，即增加每个归并段的容量；
          置换-选择排序算法
          
// 多路平衡归并算法
    对于外部排序算法来说，其直接影响算法效率的因素为读写外存的次数，即次数越多，算法效率越低。若想提高算法的效率，即减少算法运行过程中读写外存的次数，可以增加 k–路平衡归并中的 k 值；
    但是经过计算得知，如果毫无限度地增加 k 值，虽然会减少读写外存数据的次数，但会增加内部归并的时间，得不偿失。
        对于 10 个临时文件，当采用 2-路平衡归并时，若每次从 2 个文件中想得到一个最小值时只需比较 1 次；而采用 5-路平衡归并时，若每次从 5 个文件中想得到一个最小值就需要比较 4 次。以上仅仅是得到一个最小值记录，如要得到整个临时文件，其耗费的时间就会相差很大。
    为了避免在增加 k 值的过程中影响内部归并的效率，在进行 k-路归并时可以使用“败者树”来实现，该方法在增加 k 值时不会影响其内部归并的效率。
    

          
