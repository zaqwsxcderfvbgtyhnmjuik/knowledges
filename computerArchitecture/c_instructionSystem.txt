/// this is a topic about instruction system of computer architecture ///

// 指令集结构概述
    指令集：
        一些指令的集合。
        每条指令都是直接由CPU硬件执行
    
    指令的表示方式：
        二进制格式；<== 操作码 寻址方式 操作数 寻址方式 操作数
        物理存储空间组织方式是位、字节、字和多字等；
        当前的指令字长有：16、32、64位；
        可变长度格式和固定长度格式
            RISC指令是固定长度格式的，均是32字节；
            以x86为代表的CISC指令是可变长度格式的，最短可有1字节，最长可有17字节；
            
    指令的特点：
        指令的操作十分简单，其操作由操作码编码表示
        每个操作需要的操作数个数为0-3个不等
            操作数是一些存储单元的地址；
            典型的存储单元通常有：主存、寄存器、堆栈和累加器；
        
        操作数地址隐含表示或显示表示
    
        
// 指令集结构的分类
    一般来说，从以下五个因素考虑对计算机指令集结构进行分类：
        在CPU中操作数的存储方法
        指令中显示表示的操作数个数
        操作数的寻址方式
        指令集所提供的的操作类型
        操作数的类型和大小
        
    在CPU中操作数的存储方法
        CPU中用来存储操作数的存储单元主要有：
            堆栈
            累加器
            一组寄存器
        操作数地址可以隐含表示或显示表示
        
        示例：Z=X+Y表达式在这三种类型指令集结构上实现方法：
            堆栈：PUSH X; PUSH Y; ADD;POP Z; <== 操作数地址隐含表示
            累加器：LOAD X; ADD Y; Store Z; <== 累加器保存每个指令的执行结果
            寄存器-存储器：LOAD R1, X; ADD R1,Y; Store R1,Z;
            寄存器-寄存器：LOAD R1, X; LOAD R2, Y; ADD R3,R1,R2; Store R3,Z; <== ADD指令不能访问内存，只能访问寄存器
        
        早期的大多数机器都是采用堆栈型或累加器型指令结构，但是自1980年以来的大多数的机器均采用的是 寄存器型指令集结构。主要原因如下：
            集成电路技术飞速发展，得以实现一个CPU中可以集成多个寄存器；
            寄存器和CPU内部的其他存储单元一样，要比存储器快；
            对编译器而言，可以更容易有效地分配和使用寄存器；
            
        通用寄存器型指令集结构：<== 主流指令集结构
            主要优点：
                在表达式求值方面，比其他类型指令集结构都具有更大的灵活性；
                寄存器可以用来存放变量：
                    减少存储器的通讯量，加快程序的执行速度（因为寄存器比存储器快）
                    可以用更少的地址位来寻址寄存器，从而可以有效地改进程序的目标代码大小
            进一步分类：
                分类依据：
                    ALU指令到底有2个或是3个操作数？
                    在ALU指令中，有多少个操作数可以用存储器来寻址（有多少个存储器操作数）？
                类型：
                    ALU指令中存储器操作数的个数         ALU指令中操作数的最多个数      结构类型        机器实例
                        0                                   3                        RR             MIPS                        <== 最多三个操作数，都只能保存在寄存器中
                        1                                   2                        RM             IBM360/370，Intel 80x86     <== 最多二个操作数，其中一个保存在存储器中，ALU只能访问一次存储器，所以只能是源操作数在内存器中。
                                                            3                        RM             IBM360/370
                        2                                   3                        MM             VAX
                        3                                   3                        MM             VAX
                    寄存器-寄存器型：R-R:register-register  <== 实例：IBM公司的powerPC 典型的risc处理器，使用R-R型指令集结构；现已被淘汰，已经不做PC市场，转而去做服务器市场。
                        优点：指令字长固定，指令结构精简，是一种简单的代码生成模型，各种指令的执行时间周期相近。
                        缺点：与指令中含存储器操作数的指令系统结构相比，指令条数多。目标代码不够紧凑。因而程序占用的空间比较大。
                    寄存器-存储器型：R-M:register-memory    <== 实例：intel公司的x86典型的cisc微处理器，使用R-M型指令集结构；与AMD相互竞争着。
                        优点：可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。
                        缺点：
                            由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。
                            在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能限制指令所能够表示的寄存器个数。
                            指令的执行时钟周期因操作数的来源（寄存器和存储器）的不同而差别比较大。
                    存储器-存储器型：M-M:memory-memory <== 现在已经不使用了
                        优点：目标代码最紧凑，不需要设置存储器或寄存器来保存变量。
                        缺点：
                            指令字长变换很大。特别是三个操作数指令。
                            每条指令完成的工作已差别很大。
                            可以存储去的频率访问会使存储去成为瓶颈。
                            
        字长：
            存储字长：一个存储单元存储二进制代码的位数；计算机最小的存储单元是Byte，最小的存储字长是8。
            机器字长：计算机能直接处理的二进制数据的位数；
            指令字长：一个指令中包含二进制代码的总位数；
    
    指令集结构设计概观
        硬件-指令集-操作系统-应用软件
        指令集是软硬件的接口
        
// 寻址方式
    背景：在通用寄存器型指令结构中，一般是利用寻址方式指明指令中的操作数是一个常数（立即数）、一个 寄存器操作数、抑或是一个 存储器操作数。
    寻址：实际上是从形式地址（逻辑地址）到实际地址（物理地址，也称为 有效地址）的转换。
    有效地址：指明的是 存储单元的地址 或 寄存器地址。
    
    常用的一些操作数寻址方式：
        寄存器寻址：
            指令实例：Add R4, R3
            含义：Regs[R4] <--Regs[R4] + Regs[R3]
        立即数寻址：<== 最快的，操作数随同指令一起被取进CPU里面来的。
            指令实例：Add R4, #3
            含义：Regs[R4] <--Regs[R4] + 3
        偏移寻址：     <== 存储器寻址
            指令实例：Add R4, 100(R1)
            含义：Regs[R4] <--Regs[R4] + Mem[100+Regs[R1]]
        寄存器间接寻址：<== 存储器寻址
            指令实例：Add R4, (R1)
            含义：Regs[R4] <--Regs[R4] + Mem[Regs[R1]]
        索引寻址：      <== 存储器寻址 ； 别名为基址变址寻址，一般用于数组的寻址
            指令实例：Add R3, (R1+R2)
            含义：Regs[R4] <--Regs[R3] + Mem[Regs[R1]+Regs[R2]]
        直接寻址： <== 别名为绝对寻址
            指令实例：Add R1, (1001)
            含义：Regs[R1] <--Regs[R1] + Mem[1001]
        存储器间接寻址：<== 取操作数的速度最慢，一次寄存器访问，两次存储器访问，因此没有指令集使用它而弃用了
            指令实例：Add R1, @(R3)
            含义：Regs[R1] <--Regs[R1] + Mem[Mem[Regs[R3]]]
        自增寻址：<== x86中，有一组指令叫串操作指令，每处理完一个串元素时，修改保存操作数地址的寄存器，使其指向下一个串元素地址，属于自增寻址
            指令实例：Add R1, (R2)+
            含义：Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
                 Regs[R2] <--Regs[R2] + d ///< 每次访问操作数后，会对保存操作数地址的寄存器进行一个修正（加上一个偏移量），指向下一个操作数
        自减寻址：
            指令实例：Add R1, -(R2)
              含义：Regs[R2] <--Regs[R2] - d 
                   Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
        缩放寻址：
            指令实例：Add R1, 100(R2)[R3]
              含义：Regs[R1] <--Regs[R1] + Mem[100+Regs[R2]+Regs[R3]*d]
    各操作数寻址方式使用频率：gcc为例
        存储器间接寻址：1%
        缩放寻址：6%
        寄存器间接寻址：11%
        立即数寻址：39%
        偏移寻址：40%
        
// 指令系统的设计和优化
    考虑点：
        一种指令集结构中的指令到底要支持哪些类型的操作呢？ <== 这是所谓的指令集结构 功能设计问题，主要影响指令的操作码字段的设计。
    指令集操作的分类：
        算术和逻辑运算：整数的算术和逻辑操作，加减与或等
        数据传输：load/store
        控制指令：分支、跳转、过程调用和返回、自陷等
            跳转(Jump)：当控制指令为无条件改变控制流时，我们称之为“跳转”。
            分支(branch)：而当控制指令是有条件改变控制流时，我们称之为“分支”
            控制流程的改变情况：
                条件分支（conditional branch）<== 整数平均81%
                跳转（jump）<== 整数平均6%
                过程调用（call）<== 整数平均13%，包含返回
                过程返回（return）
        系统：操作系统调用、虚拟存储器管理等
        浮点：浮点操作，加减等
        十进制：十进制加减，十进制到字符的转换
        字符串：字符串移动、字符串比较、字符串搜索等
        图形：像素操作、压缩/解压操作等
        
// 指令系统的发展和改进

// 操作数的类型和大小

// MIPS指令系统结构

