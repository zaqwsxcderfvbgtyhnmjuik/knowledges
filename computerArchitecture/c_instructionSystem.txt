/// this is a topic about instruction system of computer architecture ///

// 指令集结构概述
    指令集：
        一些指令的集合。
        每条指令都是直接由CPU硬件执行
    
    指令的表示方式：
        二进制格式；<== 操作码 寻址方式 操作数 寻址方式 操作数
        物理存储空间组织方式是位、字节、字和多字等；
        当前的指令字长有：16、32、64位；
        可变长度格式和固定长度格式
            RISC指令是固定长度格式的，均是32字节；
            以x86为代表的CISC指令是可变长度格式的，最短可有1字节，最长可有17字节；
            
    指令的特点：
        指令的操作十分简单，其操作由操作码编码表示
        每个操作需要的操作数个数为0-3个不等
            操作数是一些存储单元的地址；
            典型的存储单元通常有：主存、寄存器、堆栈和累加器；
        
        操作数地址隐含表示或显示表示
    
        
// 指令集结构的分类
    一般来说，从以下五个因素考虑对计算机指令集结构进行分类：
        在CPU中操作数的存储方法
        指令中显示表示的操作数个数
        操作数的寻址方式
        指令集所提供的的操作类型
        操作数的类型和大小
        
    在CPU中操作数的存储方法
        CPU中用来存储操作数的存储单元主要有：
            堆栈
            累加器
            一组寄存器
        操作数地址可以隐含表示或显示表示
        
        示例：Z=X+Y表达式在这三种类型指令集结构上实现方法：
            堆栈：PUSH X; PUSH Y; ADD;POP Z; <== 操作数地址隐含表示
            累加器：LOAD X; ADD Y; Store Z; <== 累加器保存每个指令的执行结果
            寄存器-存储器：LOAD R1, X; ADD R1,Y; Store R1,Z;
            寄存器-寄存器：LOAD R1, X; LOAD R2, Y; ADD R3,R1,R2; Store R3,Z; <== ADD指令不能访问内存，只能访问寄存器
        
        早期的大多数机器都是采用堆栈型或累加器型指令结构，但是自1980年以来的大多数的机器均采用的是 寄存器型指令集结构。主要原因如下：
            集成电路技术飞速发展，得以实现一个CPU中可以集成多个寄存器；
            寄存器和CPU内部的其他存储单元一样，要比存储器快；
            对编译器而言，可以更容易有效地分配和使用寄存器；
            
        通用寄存器型指令集结构：<== 主流指令集结构
            主要优点：
                在表达式求值方面，比其他类型指令集结构都具有更大的灵活性；
                寄存器可以用来存放变量：
                    减少存储器的通讯量，加快程序的执行速度（因为寄存器比存储器快）
                    可以用更少的地址位来寻址寄存器，从而可以有效地改进程序的目标代码大小
            进一步分类：
                分类依据：
                    ALU指令到底有2个或是3个操作数？
                    在ALU指令中，有多少个操作数可以用存储器来寻址（有多少个存储器操作数）？
                类型：
                    ALU指令中存储器操作数的个数         ALU指令中操作数的最多个数      结构类型        机器实例
                        0                                   3                        RR             MIPS                        <== 最多三个操作数，都只能保存在寄存器中
                        1                                   2                        RM             IBM360/370，Intel 80x86     <== 最多二个操作数，其中一个保存在存储器中，ALU只能访问一次存储器，所以只能是源操作数在内存器中。
                                                            3                        RM             IBM360/370
                        2                                   3                        MM             VAX
                        3                                   3                        MM             VAX
                    寄存器-寄存器型：R-R:register-register  <== 实例：IBM公司的powerPC 典型的risc处理器，使用R-R型指令集结构；现已被淘汰，已经不做PC市场，转而去做服务器市场。
                        优点：指令字长固定，指令结构精简，是一种简单的代码生成模型，各种指令的执行时间周期相近。
                        缺点：与指令中含存储器操作数的指令系统结构相比，指令条数多。目标代码不够紧凑。因而程序占用的空间比较大。
                    寄存器-存储器型：R-M:register-memory    <== 实例：intel公司的x86典型的cisc微处理器，使用R-M型指令集结构；与AMD相互竞争着。
                        优点：可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。
                        缺点：
                            由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。
                            在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能限制指令所能够表示的寄存器个数。
                            指令的执行时钟周期因操作数的来源（寄存器和存储器）的不同而差别比较大。
                    存储器-存储器型：M-M:memory-memory <== 现在已经不使用了
                        优点：目标代码最紧凑，不需要设置存储器或寄存器来保存变量。
                        缺点：
                            指令字长变换很大。特别是三个操作数指令。
                            每条指令完成的工作已差别很大。
                            可以存储去的频率访问会使存储去成为瓶颈。
                            
        字长：
            存储字长：一个存储单元存储二进制代码的位数；计算机最小的存储单元是Byte，最小的存储字长是8。
            机器字长：计算机能直接处理的二进制数据的位数；
            指令字长：一个指令中包含二进制代码的总位数；
    
    指令集结构设计概观
        硬件-指令集-操作系统-应用软件
        指令集是软硬件的接口
        
// 寻址方式
    背景：在通用寄存器型指令结构中，一般是利用寻址方式指明指令中的操作数是一个常数（立即数）、一个 寄存器操作数、抑或是一个 存储器操作数。
    寻址：实际上是从形式地址（逻辑地址）到实际地址（物理地址，也称为 有效地址）的转换。
    有效地址：指明的是 存储单元的地址 或 寄存器地址。
    
    常用的一些操作数寻址方式：
        寄存器寻址：
            指令实例：Add R4, R3
            含义：Regs[R4] <--Regs[R4] + Regs[R3]
        立即数寻址：<== 最快的，操作数随同指令一起被取进CPU里面来的。
            指令实例：Add R4, #3
            含义：Regs[R4] <--Regs[R4] + 3
        偏移寻址：     <== 存储器寻址
            指令实例：Add R4, 100(R1)
            含义：Regs[R4] <--Regs[R4] + Mem[100+Regs[R1]]
        寄存器间接寻址：<== 存储器寻址
            指令实例：Add R4, (R1)
            含义：Regs[R4] <--Regs[R4] + Mem[Regs[R1]]
        索引寻址：      <== 存储器寻址 ； 别名为基址变址寻址，一般用于数组的寻址
            指令实例：Add R3, (R1+R2)
            含义：Regs[R4] <--Regs[R3] + Mem[Regs[R1]+Regs[R2]]
        直接寻址： <== 别名为绝对寻址
            指令实例：Add R1, (1001)
            含义：Regs[R1] <--Regs[R1] + Mem[1001]
        存储器间接寻址：<== 取操作数的速度最慢，一次寄存器访问，两次存储器访问，因此没有指令集使用它而弃用了
            指令实例：Add R1, @(R3)
            含义：Regs[R1] <--Regs[R1] + Mem[Mem[Regs[R3]]]
        自增寻址：<== x86中，有一组指令叫串操作指令，每处理完一个串元素时，修改保存操作数地址的寄存器，使其指向下一个串元素地址，属于自增寻址
            指令实例：Add R1, (R2)+
            含义：Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
                 Regs[R2] <--Regs[R2] + d ///< 每次访问操作数后，会对保存操作数地址的寄存器进行一个修正（加上一个偏移量），指向下一个操作数
        自减寻址：
            指令实例：Add R1, -(R2)
              含义：Regs[R2] <--Regs[R2] - d 
                   Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
        缩放寻址：
            指令实例：Add R1, 100(R2)[R3]
              含义：Regs[R1] <--Regs[R1] + Mem[100+Regs[R2]+Regs[R3]*d]
    各操作数寻址方式使用频率：gcc为例
        存储器间接寻址：1%
        缩放寻址：6%
        寄存器间接寻址：11%
        立即数寻址：39%
        偏移寻址：40%
        
// 指令系统的设计和优化
    考虑点：
        一种指令集结构中的指令到底要支持哪些类型的操作呢？ <== 这是所谓的指令集结构 功能设计问题，主要影响指令的操作码字段的设计。
    指令集操作的分类：
        算术和逻辑运算：整数的算术和逻辑操作，加减与或等
        数据传输：load/store
        控制指令：分支、跳转、过程调用和返回、自陷等
            跳转(Jump)：当控制指令为无条件改变控制流时，我们称之为“跳转”。
            分支(branch)：而当控制指令是有条件改变控制流时，我们称之为“分支”
            控制流程的改变情况：
                条件分支（conditional branch）<== 整数平均81%
                跳转（jump）<== 整数平均6%
                过程调用（call）<== 整数平均13%，包含返回
                过程返回（return）
        系统：操作系统调用、虚拟存储器管理等
        浮点：浮点操作，加减等
        十进制：十进制加减，十进制到字符的转换
        字符串：字符串移动、字符串比较、字符串搜索等
        图形：像素操作、压缩/解压操作等
    条件分支指令的表示：
        表示：条件码（CC），在程序的控制下，由ALU操作设置特殊的位。                  
        优点：可以自由设置分支条件。
        缺点：必须从一条指令将分支条件信息传送到分支指令，所以cc是额外状态。条件码限制了指令执行顺序
        
        表示：条件寄存器，根据比较结果测试条件寄存器。               
        优点：简单
        缺点：占用了一个寄存器
        
        表示：比较分支，比较操作是分支指令的一部分，比较受限制，即需要先进行比较产生比较结果，再根据比较结果进行跳转。                  
        优点：一条指令完成了两条指令的功能。
        缺点：分支指令的操作增多。
    分支目标地址的表示：
        一般是8bit的有符号偏移，是短转换；长转换较少，影响指令的长度。
    过程调用和返回的状态保存：
        调用者保存方法（caller saving）：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器。以备调用结束返回后能够再次访问调用者。<== 由于不知道被调用者要使用哪些寄存器，往往只能保存所有寄存器的值，然后再恢复，效率较低。
        被调用者保存方法（callee saving）：如果采用被调用者保存策略，那么被调用的过程必须保存 自己要用的寄存器，保证不会破坏过程调用者的程序执行环境。并在过程调用结束返回时恢复这些寄存器的内存，以供调用者继续往下执行时使用。<== 更加灵活，方便过程嵌套。

// 指令系统的发展和改进
    方向1：
        CISC:强化指令功能，实现软件功能向硬件功能转移，基于这种指令结构而设计实现的计算机系统称为：复杂指令集计算机（CISC : complex instruction set computer ）。
        实例:x86指令集结构是支持CISC的一个典型代表；出现了很多功能性很强的指令，比如说串操作指令，在一条指令里面，它可以完成对一个串的一个元素的处理，然后再修改偏移量，即修改偏移寄存器，为接下来处理下一个串元素做好准备；如果再加上重复前缀的话，就可以用一条指令完成对整个串的处理。   
        CISC指令集功能设计：
            面向目标程序增强指令功能：
                提高运算型指令功能
                    在一些典型的嵌入式处理器里面，它都会增加一条指令，叫做mac指令，也被称作乘累加指令；能够用一条指令计算表达式d=a*b+c（之所以设计它，是因为嵌入式运用中非常普遍），而在传统的处理器里面没有提供这条指令，要计算该表达式得先做一个乘法指令后再做一个加法指令。
                提高传送指令功能
                增加程序控制指令功能
            面向高级语言和编译程序改进指令系统：
                增加对高级语言和编译系统支持的指令功能；
                高级语言计算机指令系统向操
            向操作系统的优化实现改进指令系统：
                主要表现在对中断处理，进程管理，存储管理和保护、系统工作状态的建立与切换等等支持。 <== 表现在对操作系统中一些比较耗时的一些系统调用来提供专门的支持，包括中断处理，进程管理，硬件虚拟化技术（其实现都是通过在指令系统里面增加专门的虚拟化指令来实现的，通过增加这些虚拟化指令，虚拟化管理器里面的一些耗时操作可以用指令来实现，所以呢这些操作效率就提高了）等
                可以设置支持系统工作状态和访问方式转移的指令、支持进程转移的指令、支持进程同步和互斥的指令等措施。达到优化实现操作系统的目的。
        CISC结构存在着如下缺点：
            1) CISC结构的指令系统中，各种指令的使用频率相差悬殊；据统计，有20%的指令使用频率最大，占运行时间的80%。也就是说，80%的指令在20%的运行时间内才会用到；<== 大多数实现指令的元器件未使用到。    方向2：
            2) CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误；
            3) CISC结构指令系统的复杂性给VLSI设计增加了很大负担，不利于单片集成；
            4) CISC结构的指令系统中，许多复杂指令需要很复杂的操作，因而运行速度慢；
            5) CISC结构的指令系统中，由于各条指令的功能不均衡，不利于采用先进的计算机体系结构技术（流水线技术）来提高系统的性能。
            补充：那么为什么x86仍然是一个CISC指令集，现在（2012年）在整个的桌面市场上占据了统治性的地位，就是还保持着这样一个强有力的优势呢？
                原因是多方面的；
                另外一个情况是从奔腾4处理器开始，x86已经实现了内核的RISC化，意思就是虽然我们程序员（汇编语言）看到的X86指令集还是一个CISC指令集，但是x86的内部它已经在执行这个CISC指令之前，先把所有的CISC指令都转化成RISC指令。换句话说，CISC指令严重地限制了x86内核的不断的升级和改进，因为其复杂度实在是太高了。所以x86从奔腾4开始，才会把内核改为RISC内核。                
        RISC:20世纪80年代发展起来的精简指令集计算机（RISC : reduced instruction set computer ），其目的是尽可能的降低 指令集结构的复杂性，以达到简化CPU的实现，从而提高性能的目的。.
        实例:奔腾4以后的x86指令集
        RISC指令集功能设计：
            一组统计：
                执行频率排序      80x86（简称x86）       指令执行频率
                1                load                  22%
                2                条件分支               20%
                3                比较                  16%
                4                store                 12%
                5                加                    8%
                6                与                    6%
                7                减                    5%
                8                寄存器-寄存器间数据移动 4%
                9                调用                  1%
                10               返回                  1%
                合计                                   96%
            进行RISC计算机指令集结我们并不能简单的着眼于精简指令系统上，更重要的目的是使得计算机体系结构更加简单、更加合理和更加有效，克服CISC指令集结构的缺点，使机器速度更快，程序运行时间缩短，从而提高计算机系统的性能。
        RISC指令集功能设计原则：
            1) 选取使用频率最高的指令，在此基础上，补充一些最有用的指令；<== 考虑功能的完备性出发，换句话说，CISC指令集能做的事，我用RISC指令集都能实现，但首先不考虑实现的效率（就是不考虑实现同样一个程序所需要的指令数）。
            2) 每条指令的功能应尽可能简单，并在一个机器周期内完成； <== 有利于今后使用流水线技术来实现这个指令集
            3) 所有指令长度均相同；<== 非常规整，带来一个好处：在储存器里面存储以及访问存储器取出这些指令都会更加方便，存储器效率会提高
            4) 只有load和store操作指令才能访问存储器，其他指令操作均在寄存器之间进行；<== 借助如预取技术、Cache技术等缩短访存开销
            5) 以简单有效的方式支持高级语言；
            
// 操作数的类型和大小
    操作数类型：
        操作数类型和操作数表示，也是软硬件主要界面之一。
        操作数类型是面向应用、面向软件系统所处理的各种数据结构。
        操作数表示是硬件结构能够识别、指令系统可以直接调用的那些结构。
        操作数表示所表征的那些操作数类型，是应用软件和系统软件所处理的操作数类型的子集。
        确定操作数表示实际上也是软硬件取舍折衷的问题：
            计算机即使只具有最简单的操作数表示，如只有整数（定点）表示法，也可以通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率。
            如果各种复杂的操作数类型均包含在操作数表示之中，无疑会大大提高系统的效率，但是所花费的硬件代价也很高。
        典型的操作数类型表示：
            整数（定点）：二进制补码表示；其大小可以是字节（8bit）、半字（16bit）或单字（32bit）；
            浮点：可以分为单精度浮点（单字大小）和双精度大小（双字大小）。当前普遍采用的是IEEE754浮点操作数表示标准；
            字符和字符串：8bit ASCII码表示；
            十进制：
                通常采用"压缩十进制"和"二进制编码十进制"表示。压缩十进制数据表示用四位编码数字0~9，然后将两个十进制数字压缩在一个字节中存储；如果将十进制数字直接用字符串来表示，就叫做非压缩十进制表示法。
                提供给 压缩十进制表示法 和 非压缩十进制表示法 两者之间相互转换的操作分别为压缩与解压操作。
        操作数类型的表示主要有如下两种方法：
            1) 操作数的类型可以由操作码的编码指定，这也是最常见的一种方法； <== 一般情况下
            2) 数据可以附上由硬件解释的标记，由这些标记指定操作数的类型，从而选择适当的运算，然而有标记的数据的机器却非常少见。
    操作数大小：
        一般的操作数类型大小选择主要有：字节、半字（16bit）、单字（32bit）和双字（64bit）
        一组统计：
            字节      7% （整数）
            半字      19%（整数）
            单字      74%（整数）31%（浮点） <== 2012年时，大部分计算机都是32位计算机有关
            双字      0% （整数）69%（浮点） <== 考虑到数据精度的问题，双精度浮点数用的比较多
            
// MIPS指令系统结构

