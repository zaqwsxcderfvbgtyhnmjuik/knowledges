/// this is a topic about instruction system of computer architecture ///

// 指令集结构概述
    指令集：
        一些指令的集合。
        每条指令都是直接由CPU硬件执行
    
    指令的表示方式：
        二进制格式；<== 操作码 寻址方式 操作数 寻址方式 操作数
        物理存储空间组织方式是位、字节、字和多字等；
        当前的指令字长有：16、32、64位；
        可变长度格式和固定长度格式
            RISC指令是固定长度格式的，均是32字节；
            以x86为代表的CISC指令是可变长度格式的，最短可有1字节，最长可有17字节；
            
    指令的特点：
        指令的操作十分简单，其操作由操作码编码表示
        每个操作需要的操作数个数为0-3个不等
            操作数是一些存储单元的地址；
            典型的存储单元通常有：主存、寄存器、堆栈和累加器；
        
        操作数地址隐含表示或显示表示
    
        
// 指令集结构的分类
    一般来说，从以下五个因素考虑对计算机指令集结构进行分类：
        在CPU中操作数的存储方法
        指令中显示表示的操作数个数
        操作数的寻址方式
        指令集所提供的的操作类型
        操作数的类型和大小
        
    在CPU中操作数的存储方法
        CPU中用来存储操作数的存储单元主要有：
            堆栈
            累加器
            一组寄存器
        操作数地址可以隐含表示或显示表示
        
        示例：Z=X+Y表达式在这三种类型指令集结构上实现方法：
            堆栈：PUSH X; PUSH Y; ADD;POP Z; <== 操作数地址隐含表示
            累加器：LOAD X; ADD Y; Store Z; <== 累加器保存每个指令的执行结果
            寄存器-存储器：LOAD R1, X; ADD R1,Y; Store R1,Z;
            寄存器-寄存器：LOAD R1, X; LOAD R2, Y; ADD R3,R1,R2; Store R3,Z; <== ADD指令不能访问内存，只能访问寄存器
        
        早期的大多数机器都是采用堆栈型或累加器型指令结构，但是自1980年以来的大多数的机器均采用的是 寄存器型指令集结构。主要原因如下：
            集成电路技术飞速发展，得以实现一个CPU中可以集成多个寄存器；
            寄存器和CPU内部的其他存储单元一样，要比存储器快；
            对编译器而言，可以更容易有效地分配和使用寄存器；
            
        通用寄存器型指令集结构：<== 主流指令集结构
            主要优点：
                在表达式求值方面，比其他类型指令集结构都具有更大的灵活性；
                寄存器可以用来存放变量：
                    减少存储器的通讯量，加快程序的执行速度（因为寄存器比存储器快）
                    可以用更少的地址位来寻址寄存器，从而可以有效地改进程序的目标代码大小
            进一步分类：
                分类依据：
                    ALU指令到底有2个或是3个操作数？
                    在ALU指令中，有多少个操作数可以用存储器来寻址（有多少个存储器操作数）？
                类型：
                    ALU指令中存储器操作数的个数         ALU指令中操作数的最多个数      结构类型        机器实例
                        0                                   3                        RR             MIPS                        <== 最多三个操作数，都只能保存在寄存器中
                        1                                   2                        RM             IBM360/370，Intel 80x86     <== 最多二个操作数，其中一个保存在存储器中，ALU只能访问一次存储器，所以只能是源操作数在内存器中。
                                                            3                        RM             IBM360/370
                        2                                   3                        MM             VAX
                        3                                   3                        MM             VAX
                    寄存器-寄存器型：R-R:register-register  <== 实例：IBM公司的powerPC 典型的risc处理器，使用R-R型指令集结构；现已被淘汰，已经不做PC市场，转而去做服务器市场。
                        优点：指令字长固定，指令结构精简，是一种简单的代码生成模型，各种指令的执行时间周期相近。
                        缺点：与指令中含存储器操作数的指令系统结构相比，指令条数多。目标代码不够紧凑。因而程序占用的空间比较大。
                    寄存器-存储器型：R-M:register-memory    <== 实例：intel公司的x86典型的cisc微处理器，使用R-M型指令集结构；与AMD相互竞争着。
                        优点：可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。
                        缺点：
                            由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。
                            在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能限制指令所能够表示的寄存器个数。
                            指令的执行时钟周期因操作数的来源（寄存器和存储器）的不同而差别比较大。
                    存储器-存储器型：M-M:memory-memory <== 现在已经不使用了
                        优点：目标代码最紧凑，不需要设置存储器或寄存器来保存变量。
                        缺点：
                            指令字长变换很大。特别是三个操作数指令。
                            每条指令完成的工作已差别很大。
                            可以存储去的频率访问会使存储去成为瓶颈。
                            
        字长：
            存储字长：一个存储单元存储二进制代码的位数；计算机最小的存储单元是Byte，最小的存储字长是8。
            机器字长：计算机能直接处理的二进制数据的位数；
            指令字长：一个指令中包含二进制代码的总位数；
    
    指令集结构设计概观
        硬件-指令集-操作系统-应用软件
        指令集是软硬件的接口
        
// 寻址方式
    背景：在通用寄存器型指令结构中，一般是利用寻址方式指明指令中的操作数是一个常数（立即数）、一个 寄存器操作数、抑或是一个 存储器操作数。
    寻址：实际上是从形式地址（逻辑地址）到实际地址（物理地址，也称为 有效地址）的转换。
    有效地址：指明的是 存储单元的地址 或 寄存器地址。
    
    常用的一些操作数寻址方式：
        寄存器寻址：
            指令实例：Add R4, R3
            含义：Regs[R4] <--Regs[R4] + Regs[R3]
        立即数寻址：<== 最快的，操作数随同指令一起被取进CPU里面来的。
            指令实例：Add R4, #3
            含义：Regs[R4] <--Regs[R4] + 3
        偏移寻址：     <== 存储器寻址
            指令实例：Add R4, 100(R1)
            含义：Regs[R4] <--Regs[R4] + Mem[100+Regs[R1]]
        寄存器间接寻址：<== 存储器寻址
            指令实例：Add R4, (R1)
            含义：Regs[R4] <--Regs[R4] + Mem[Regs[R1]]
        索引寻址：      <== 存储器寻址 ； 别名为基址变址寻址，一般用于数组的寻址
            指令实例：Add R3, (R1+R2)
            含义：Regs[R4] <--Regs[R3] + Mem[Regs[R1]+Regs[R2]]
        直接寻址： <== 别名为绝对寻址
            指令实例：Add R1, (1001)
            含义：Regs[R1] <--Regs[R1] + Mem[1001]
        存储器间接寻址：<== 取操作数的速度最慢，一次寄存器访问，两次存储器访问，因此没有指令集使用它而弃用了
            指令实例：Add R1, @(R3)
            含义：Regs[R1] <--Regs[R1] + Mem[Mem[Regs[R3]]]
        自增寻址：<== x86中，有一组指令叫串操作指令，每处理完一个串元素时，修改保存操作数地址的寄存器，使其指向下一个串元素地址，属于自增寻址
            指令实例：Add R1, (R2)+
            含义：Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
                 Regs[R2] <--Regs[R2] + d ///< 每次访问操作数后，会对保存操作数地址的寄存器进行一个修正（加上一个偏移量），指向下一个操作数
        自减寻址：
            指令实例：Add R1, -(R2)
              含义：Regs[R2] <--Regs[R2] - d 
                   Regs[R1] <--Regs[R1] + Mem[Regs[R2]]
        缩放寻址：
            指令实例：Add R1, 100(R2)[R3]
              含义：Regs[R1] <--Regs[R1] + Mem[100+Regs[R2]+Regs[R3]*d]
    各操作数寻址方式使用频率：gcc为例
        存储器间接寻址：1%
        缩放寻址：6%
        寄存器间接寻址：11%
        立即数寻址：39%
        偏移寻址：40%
        
// 指令系统的设计和优化
    考虑点：
        一种指令集结构中的指令到底要支持哪些类型的操作呢？ <== 这是所谓的指令集结构 功能设计问题，主要影响指令的操作码字段的设计。
    指令集操作的分类：
        算术和逻辑运算：整数的算术和逻辑操作，加减与或等
        数据传输：load/store
        控制指令：分支、跳转、过程调用和返回、自陷等
            跳转(Jump)：当控制指令为无条件改变控制流时，我们称之为“跳转”。
            分支(branch)：而当控制指令是有条件改变控制流时，我们称之为“分支”
            控制流程的改变情况：
                条件分支（conditional branch）<== 整数平均81%
                跳转（jump）<== 整数平均6%
                过程调用（call）<== 整数平均13%，包含返回
                过程返回（return）
        系统：操作系统调用、虚拟存储器管理等
        浮点：浮点操作，加减等
        十进制：十进制加减，十进制到字符的转换
        字符串：字符串移动、字符串比较、字符串搜索等
        图形：像素操作、压缩/解压操作等
    条件分支指令的表示：
        表示：条件码（CC），在程序的控制下，由ALU操作设置特殊的位。                  
        优点：可以自由设置分支条件。
        缺点：必须从一条指令将分支条件信息传送到分支指令，所以cc是额外状态。条件码限制了指令执行顺序
        
        表示：条件寄存器，根据比较结果测试条件寄存器。               
        优点：简单
        缺点：占用了一个寄存器
        
        表示：比较分支，比较操作是分支指令的一部分，比较受限制，即需要先进行比较产生比较结果，再根据比较结果进行跳转。                  
        优点：一条指令完成了两条指令的功能。
        缺点：分支指令的操作增多。
    分支目标地址的表示：
        一般是8bit的有符号偏移，是短转换；长转换较少，影响指令的长度。
    过程调用和返回的状态保存：
        调用者保存方法（caller saving）：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器。以备调用结束返回后能够再次访问调用者。<== 由于不知道被调用者要使用哪些寄存器，往往只能保存所有寄存器的值，然后再恢复，效率较低。
        被调用者保存方法（callee saving）：如果采用被调用者保存策略，那么被调用的过程必须保存 自己要用的寄存器，保证不会破坏过程调用者的程序执行环境。并在过程调用结束返回时恢复这些寄存器的内存，以供调用者继续往下执行时使用。<== 更加灵活，方便过程嵌套。

// 指令系统的发展和改进
    方向1：
        CISC:强化指令功能，实现软件功能向硬件功能转移，基于这种指令结构而设计实现的计算机系统称为：复杂指令集计算机（CISC : complex instruction set computer ）。
        实例:x86指令集结构是支持CISC的一个典型代表；出现了很多功能性很强的指令，比如说串操作指令，在一条指令里面，它可以完成对一个串的一个元素的处理，然后再修改偏移量，即修改偏移寄存器，为接下来处理下一个串元素做好准备；如果再加上重复前缀的话，就可以用一条指令完成对整个串的处理。   
        CISC指令集功能设计：
            面向目标程序增强指令功能：
                提高运算型指令功能
                    在一些典型的嵌入式处理器里面，它都会增加一条指令，叫做mac指令，也被称作乘累加指令；能够用一条指令计算表达式d=a*b+c（之所以设计它，是因为嵌入式运用中非常普遍），而在传统的处理器里面没有提供这条指令，要计算该表达式得先做一个乘法指令后再做一个加法指令。
                提高传送指令功能
                增加程序控制指令功能
            面向高级语言和编译程序改进指令系统：
                增加对高级语言和编译系统支持的指令功能；
                高级语言计算机指令系统向操
            向操作系统的优化实现改进指令系统：
                主要表现在对中断处理，进程管理，存储管理和保护、系统工作状态的建立与切换等等支持。 <== 表现在对操作系统中一些比较耗时的一些系统调用来提供专门的支持，包括中断处理，进程管理，硬件虚拟化技术（其实现都是通过在指令系统里面增加专门的虚拟化指令来实现的，通过增加这些虚拟化指令，虚拟化管理器里面的一些耗时操作可以用指令来实现，所以呢这些操作效率就提高了）等
                可以设置支持系统工作状态和访问方式转移的指令、支持进程转移的指令、支持进程同步和互斥的指令等措施。达到优化实现操作系统的目的。
        CISC结构存在着如下缺点：
            1) CISC结构的指令系统中，各种指令的使用频率相差悬殊；据统计，有20%的指令使用频率最大，占运行时间的80%。也就是说，80%的指令在20%的运行时间内才会用到；<== 大多数实现指令的元器件未使用到。    方向2：
            2) CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误；
            3) CISC结构指令系统的复杂性给VLSI设计增加了很大负担，不利于单片集成；
            4) CISC结构的指令系统中，许多复杂指令需要很复杂的操作，因而运行速度慢；
            5) CISC结构的指令系统中，由于各条指令的功能不均衡，不利于采用先进的计算机体系结构技术（流水线技术）来提高系统的性能。
            补充：那么为什么x86仍然是一个CISC指令集，现在（2012年）在整个的桌面市场上占据了统治性的地位，就是还保持着这样一个强有力的优势呢？
                原因是多方面的；
                另外一个情况是从奔腾4处理器开始，x86已经实现了内核的RISC化，意思就是虽然我们程序员（汇编语言）看到的X86指令集还是一个CISC指令集，但是x86的内部它已经在执行这个CISC指令之前，先把所有的CISC指令都转化成RISC指令。换句话说，CISC指令严重地限制了x86内核的不断的升级和改进，因为其复杂度实在是太高了。所以x86从奔腾4开始，才会把内核改为RISC内核。                
        RISC:20世纪80年代发展起来的精简指令集计算机（RISC : reduced instruction set computer ），其目的是尽可能的降低 指令集结构的复杂性，以达到简化CPU的实现，从而提高性能的目的。.
        实例:奔腾4以后的x86指令集
        RISC指令集功能设计：
            一组统计：
                执行频率排序      80x86（简称x86）       指令执行频率
                1                load                  22%
                2                条件分支               20%
                3                比较                  16%
                4                store                 12%
                5                加                    8%
                6                与                    6%
                7                减                    5%
                8                寄存器-寄存器间数据移动 4%
                9                调用                  1%
                10               返回                  1%
                合计                                   96%
            进行RISC计算机指令集结我们并不能简单的着眼于精简指令系统上，更重要的目的是使得计算机体系结构更加简单、更加合理和更加有效，克服CISC指令集结构的缺点，使机器速度更快，程序运行时间缩短，从而提高计算机系统的性能。
        RISC指令集功能设计原则：
            1) 选取使用频率最高的指令，在此基础上，补充一些最有用的指令；<== 考虑功能的完备性出发，换句话说，CISC指令集能做的事，我用RISC指令集都能实现，但首先不考虑实现的效率（就是不考虑实现同样一个程序所需要的指令数）。
            2) 每条指令的功能应尽可能简单，并在一个机器周期内完成； <== 有利于今后使用流水线技术来实现这个指令集
            3) 所有指令长度均相同；<== 非常规整，带来一个好处：在储存器里面存储以及访问存储器取出这些指令都会更加方便，存储器效率会提高
            4) 只有load和store操作指令才能访问存储器，其他指令操作均在寄存器之间进行；<== 借助如预取技术、Cache技术等缩短访存开销
            5) 以简单有效的方式支持高级语言；
            
// 操作数的类型和大小
    操作数类型：
        操作数类型和操作数表示，也是软硬件主要界面之一。
        操作数类型是面向应用、面向软件系统所处理的各种数据结构。
        操作数表示是硬件结构能够识别、指令系统可以直接调用的那些结构。
        操作数表示所表征的那些操作数类型，是应用软件和系统软件所处理的操作数类型的子集。
        确定操作数表示实际上也是软硬件取舍折衷的问题：
            计算机即使只具有最简单的操作数表示，如只有整数（定点）表示法，也可以通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率。
            如果各种复杂的操作数类型均包含在操作数表示之中，无疑会大大提高系统的效率，但是所花费的硬件代价也很高。
        典型的操作数类型表示：
            整数（定点）：二进制补码表示；其大小可以是字节（8bit）、半字（16bit）或单字（32bit）；
            浮点：可以分为单精度浮点（单字大小）和双精度大小（双字大小）。当前普遍采用的是IEEE754浮点操作数表示标准；
            字符和字符串：8bit ASCII码表示；
            十进制：
                通常采用"压缩十进制"和"二进制编码十进制"表示。压缩十进制数据表示用四位编码数字0~9，然后将两个十进制数字压缩在一个字节中存储；如果将十进制数字直接用字符串来表示，就叫做非压缩十进制表示法。
                提供给 压缩十进制表示法 和 非压缩十进制表示法 两者之间相互转换的操作分别为压缩与解压操作。
        操作数类型的表示主要有如下两种方法：
            1) 操作数的类型可以由操作码的编码指定，这也是最常见的一种方法； <== 一般情况下
            2) 数据可以附上由硬件解释的标记，由这些标记指定操作数的类型，从而选择适当的运算，然而有标记的数据的机器却非常少见。
    操作数大小：
        一般的操作数类型大小选择主要有：字节、半字（16bit）、单字（32bit）和双字（64bit）
        一组统计：
            字节      7% （整数）
            半字      19%（整数）
            单字      74%（整数）31%（浮点） <== 2012年时，大部分计算机都是32位计算机有关
            双字      0% （整数）69%（浮点） <== 考虑到数据精度的问题，双精度浮点数用的比较多
            
// MIPS指令系统结构
    概念：MIPS architecture，为Microprocessor without interlocked piped stages architecture（微处理器没有联锁管级结构） ，亦为Millions of instructions per second的双关语；是一种采取精简指令集的处理器架构，1981年出现，由MIPS公司开发并授权，最早是32位，最新是64位。
    Load/Store型指令集结构：
        所有ALU指令的所有源操作数、目的操作数都只能保存在寄存器里面，只能通过Load和Store指令来访问存储器，因此是一个Load/Store型指令集结构。
    MIPS是一种多元指令集结构
        体现了当今（2012年）多种机器（AMD29K、Intel i860、RISC I、IBM801、HP850、Motorola 88k）的指令集结构的共同特点;
        还将会体现未来一些机器指令结构的特点;
    MIPS特点：
        1) 具有一个简单的Load/Store指令集
        2) 注重指令流水效率
        3) 简化指令的译码
        4) 高效支持编译器
    MIPS寄存器：
        1) 提供32个32位的通用型寄存器（GPRs：General-Purpose Register）R0,R1,...,R30,R31；寄存器R0的内容恒为全0 ；
        2) 提供32个32位单精度浮点寄存器（FPRs：Floating-Point Register）F0,F1,...,F30,F31；还可以组织成16个双精度浮点寄存器；
    MIPS数据类型：
        整数类型：
            8位、16位、32位；
        浮点数据：
            32位单精度浮点；
            64位双精度浮点；
            IEEE754标准；<== 均遵循该协议规则
    MIPS寻址方式：
        1) 寄存器寻址；如ADD R1,R2,R3
        2) 立即数寻址；如ADD R1,R2,#42
        3) 偏移寻址；  如ADD R1,R2,40(R3)
        4) 寄存器间接寻址；存储器地址宽度为32位（2012年）；如ADD R1,R2,0(R3)
    MIPS指令格式：
        I类型指令：<== I表示立即数（immediate number）
            操作码  rs1   rd    立即值
            6bit   5bit  5bit  16bit
            rs1：register source address <== 源寄存器地址
            rd：register destination addreess <== 目标寄存器地址
            语义：
                将rs1地址标识的寄存器中的值 同 立即值 进行操作，将结果保存到rd地址标识的寄存器中；
                即：rd <—— rs1 op 立即值 <== op由操作码指明
        R类型指令：<== R表示寄存器（Register）
            操作码  rs1   rs2   rd     Func
            6bit   5bit  5bit  5bit   11bit
            语义：
                将rs1地址标识的寄存器中的值 同 rs2地址标识的寄存器中的值 进行Func操作，将结果保存到rd地址标识的寄存器中；
                即：rd <—— rs1 Func rs2 <== 进行Func操作，所有R类型指令的操作码是固定的唯一一个值※；
                    寄存器-寄存器ALU操作
                    函数对数据的操作进行编码：加、减、...；
                    对特殊寄存器的读/写和移动。
        J类型指令：<== J表示跳转（jump）
            操作码  与PC相加的偏移量 <== PC指：Program Counter Register（程序计数寄存器），用来存储指向下一条指令的地址，也即将将要执行的指令代码
            6bit   26bit
            语义：
                将PC寄存器的值修改为PC寄存器当前值+26bit表示的偏移地址，改变将要执行的指令；
                PC <—— RC + 偏移地址
                    跳转，跳转并链接，从异常（exception）处自陷和返回
    MIPS操作类型：
        Load和Store操作：
            可以对MIPS的所有通用型寄存器（包括R0）和浮点寄存器进行Load(载入)和Store(存储)操作，但是对通用寄存器R0的Load操作没有任何效果。※
            实例：
                指令实例            指令名称                        含义
                LW R1,30(R2)       载入整型字                Regs[R1] <——32 Mem[30+Regs[R2]]
                LW R1,1000(R0)     载入整型字                Regs[R1] <——32 Mem[1000+0] <== Regs[R0]始终是0
                LB R1,40(R3)       载入字节                  Regs[R1] <——32 (Mem[40+Regs[R3]]0)^24 ## Mem[40+Regs[R3]] <== 对符号位进行拓展：取出符号位后复制24次，再和第八位的数值拼接到一起；
                LBU R1,40(R3)      载入无符号字节             Regs[R1] <——32 0^24 ## Mem[40+Regs[R3]]   <== 无符号数进行0拓展，即对0进行24次复制
                LH R1,40(R3)       载入整形半字              Regs[R1] <——32 (Mem[40+Regs[R3]]0)^16 ## Mem[40+Regs[R3]] ## Mem[41+Regs[R3]]
                LF F0,50(R3)       载入单精度浮点            Regs[F0] <——32 Mem[50+Regs[R3]]
                LD F0,50(R2)       载入双精度浮点            Regs[F0] ## Regs[F1] <——64 Mem[50+Regs[R2]]
                
                SW 500(R4),R3      存储整型字                Mem[500+Regs[R4]] <——32 Regs[R3]
                SF 40(R3),F0       存储单精度浮点            Mem[40+Regs[R3]] <——32 Regs[F0]
                SD 40(R3),F0       存储双精度浮点            Mem[40+Regs[R3]] <——32 Regs[F0];Mem[44+Regs[R3]] <——32 Regs[F1]
                SH 502(R2),R31     存储整型半字             Mem[502+Regs[R2]] <——16 Regs[31]16...31 <== 截断处理，如果有符号数最高位是1，截断的低16位的最高位正好是0的话则出错※
                SB 41(R3),R2       存储整型字节             Mem[41+Regs[R3]] <——8 Regs[R2]24...31   <== 截断处理，编程时注意这一点错误
                
        ALU操作：
            在MIPS中，所有ALU指令都是寄存器-寄存器型指令，其运算包含了简单的算术和逻辑运算，如加、减、AND、OR、XOR和移位。
            "设置相等"、"设置不等"、"设置小于"：寄存器比较指令（等于、不等于、小于、大于、小于等于、大于等于），如果比较结果为真，这些指令就在目标寄存器中填入1（表示真），否则填入0（表示假）；        浮点操作
            实例：
                指令实例                指令名称                含义
                Add R1,R2,R3            加              Regs[R1] <—— Regs[R2] + Regs[R3] 
                ADDI R1,R2,#3           和立即数相加     Regs[R1] <—— Regs[R2] + 3
                LHI R1, #42             载入高位立即数   Regs[R1] <—— 42 ## 0^16
                SLLI R1,R2,#5           逻辑左移立即数形式Regs[R1] <—— Regs[R2] << 5
                SLT R1,R2,R3            设置小于         if (Regs[R2] < Regs[R3]) Regs[R1] <—— 1 else Regs[R1] <—— 0
        分支和跳转操作：
            描述目标地址的方法：
                其中两种类型的跳转指令用带符号位的26位偏移量加上 程序计数器的值来确定跳转的目标地址；
                另外两种类型的跳转指令则指定一个寄存器，由寄存器中的内容决定跳转的目标地址；
            两种跳转类型：
                一种是简单跳转；
                另一种是跳转并链接（用于过程调用），它将下一条顺序指令地址（返回地址）保存在寄存器R31中；
            实例：
                指令实例                指令名称                含义
                J name                  跳转             PC<——name+PC+4; -2^25 <=name<=2^25 <== PC+4表示下一条指令的地址
                JAL name                跳转并链接        Regs[R31] <—— PC+4; <== 保存下一条指令地址，便于过程结束后继续执行
                                                         PC<——name+PC+4; -2^25 <=name<=2^25
                JR R3                   寄存器型跳转      PC<——Regs[R3]
                JALR R2                 寄存器型跳转并链接Regs[R31] <—— PC+4;
                                                         PC<——Regs[R2]
                BEQZ R4,name            "等于0"分支       if(Regs[R4]==0) PC<——name+PC+4; -2^25 <=name<=2^25
                BNEZ R4,name            "不等于0"分支     if(Regs[R4]!=0) PC<——name+PC+4; -2^25 <=name<=2^25 
        浮点操作：
            浮点指令的操作数来源于浮点寄存器，同时他还指明了相应的操作是单精度浮点操作，还是双精度浮点操作。
            后缀D代表双精度浮点操作，而后缀F代表单精度浮点操作。如ADDD、ADDF、SUBD、SUBF、MULTD、MULTF、DIVD、DIVF
            
        补充：约定
            1) 符号"<——"表示数据传送操作，其后附带一个下标n，也即"<——n"表示传送一个n位数据
            2) 符号"##"用来表示两个域的串联操作（两个二进制串的拼接操作），它可以出现在数据传送操作的任何一边
            3) 域的下标用来表明从该域中选择某一位。
                域中位的标记是从最高位开始标记，并且起始标记为0；
                下标可以是一个单独的数字，如Regs[R4]0表示选择寄存器R4中内容的符号位；
                下标也可以是一个范围，如Regs[R3]24...31表示选择寄存器R3中内容的最低一个字节；
            4) 域的上标表示复制一个域，如0^24可以得到一个24位全为0的一个域
            5) 变量Mem用来表示存储器中的一个数组，存储器按照字节寻址，它可以传送任何数目的字节；
            示例：
                Regs[R10]16...31 <——16 (Mem[Regs[R8]]0)^8 ## Mem[Regs[R8]]
                    a.通过Mem[Regs[R8]]取得一个字节的二进制串为：10000101
                    b.将a.的结果和(Mem[Regs[R8]]0)^8 符号位的拓展进行拼接为：11111111 10000101
                    c.将b.的结果传送给Regs[R10]的低16位，高16位保持不变。
        问题的提出：<== 实际上并不是，得益于流水线技术而是CISC性能的1.5倍左右
            MIPS指令集结构的指令格式、寻址方式和操作都非常简单。
            也许有人会担心这些特性会使得目标代码中指令条数增多导致程序运行时间加长从而使这种指令集结构的机器性能并不会太高。
            Tcpu = IC x CPI x Tclk
        
