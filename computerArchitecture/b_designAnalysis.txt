/// this is a topic about computer system design and analysis /// 
基准测试程序
    性能与测试程序的执行时间相关，那么要用什么做测试程序呢？
    五类测试程序
        真实程序
        脚本化运用程序
        核心程序
        小测试程序
        合成测试程序
    测试程序包：www.SPEC.org
        选择一组各个方面有代表性的测试程序组成
        尽可能全面地测试了一个计算机系统的性能<==>等价于买一辆车，能拉多少货，能跑什么路一样
        
量化设计基本原则
    大概率事件优先原则
        追求全局最优结果
        好钢用在刀刃上，事半功倍
    Amdahl定律
        系统性能加速比，受限于该部件在系统中所占的重要性
        可以定量计算
            假设我们对机器（部件）进行某种改进，那么机器系统（部件）的加速比就是：
                系统加速比 = 改进前系统性能/改进后系统性能 = 改进前总执行时间/改进后总执行时间
            核心概念：时间
                系统加速比告诉我们改进后比改进前快了多少。
            改进后总执行时间
                = （1 - 可改进比例）x 改进前总执行时间 + （可改进比例 x 改进前总执行时间）/ 部件加速比
                = 改进前总执行时间 x [（1 - 可改进比例）+ 可改进比例/部件加速比]
            系统加速比
                = 改进前总执行时间/改进后总执行时间
                = 1 / [（1 - 可改进比例）+ 可改进比例/部件加速比] <== 一般大于1
        观点
            性能增加的递减规则       <==系统性能增加函数的导数虽大于0，但是导数的增长越来越缓慢
                仅仅对计算机中的一部分做性能改进，则改进的越多，系统获得的效果越小
            重要推论
                针对整个任务的一部分进行优化，则最大加速比不大于：1 /（1 - 可改进比例），即假使整个任务的一部分执行时间为零后的系统加速比
            衡量一个“好”计算机系统
                具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能。
            
    程序的局部性原理
        程序执行时所访问存储器在时-空上是相对的聚簇，即程序访问地址的分布不是随机的，而是相对的聚簇，包括时间局部性和空间局部性
        这种聚簇包括指令和数据两部分
        程序的时间局部性
            程序即将用到的信息很可能就是目前正在使用的信息
        程序的空间局部性
            程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或临近
        其他局部性
            生产-消费局部性 <==现在的GPU对于图形图像的处理就是采用这样的方法，充分利用了生产-消费局部性，数据不会存在环状的结构。
            
CPU性能
    程序执行过程中所处理的指令数，记为IC <== instruction count
    每条指令执行所需要的时钟周期数CPI <== cycles per instruction 
    每条指令执行所需要的平均时钟周期数
        ACPI = CLK / IC <== average cycles per instruction = (clocks of a program) / (instruction count of a program )
    
    假设计算机系统有n种指令，其中第i种指令的处理时间为CPIi，在程序中第i种指令出现的次数为ICi。
        Tcpu = CLK / f
             = ∑<i=1, i=n> [ICi x CPIi] / f <== ∑<i=1, i=n>[f(i)] = f(1) + f(2) +...+ f(n-1) + f(n)
             = ∑<i=1, i=n> [ICi x CPIi] x Tclk
     
        ACPI = CLK / IC
             = ∑<i=1, i=n> [ICi x CPIi] / IC
             = ∑<i=1, i=n> [(ICi / IC) x CPIi] 
             其中：(ICi / IC)反映了第i种指令在程序中所占的比例。<==如果第i种指令所占的比例比较高，就可以花更大的功夫对它进行优化，比如加法指令。
     
     时钟倍数：CPUa的一个时钟周期时间/CPUb的一个时钟周期时间
                
             
             
        
