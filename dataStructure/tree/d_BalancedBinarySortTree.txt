/// this is a topic about bbst ///      
平衡二叉排序树:balanced Binary sort tree
    背景：
        问题：二叉排序树最坏情况下的ASL是(n+1)2,退化到同线性表线性查找一个级别；这是一个有待解决的客观问题。
        解决方法：做"平衡化"处理，即尽量让二叉树的形态平衡。
            关键点1：如何来界定一种适度的平衡标准
                平衡因子：
                    balFac(v) = height(lr(v)) - height(rc(v)) // 节点v的平衡因子=v的左子树的高度 - v的右子树的高度
                适度平衡标准：
                    G. Adelson-Velsky & E. Landis (1962): ∀ v, | balFac(v)| <= 1 // 任意节点的平衡因子绝对值小于等于1
                    证明：
                        height(AVL) = O(logn)
                        等价于证明，在高度固定的情况下，节点也不至于太少
                            n = 2 ^ height(AVL)
                        即证明：高度为h的AVL树，至少包含S(h) = fib(h + 3) - 1个节点，S(h):高度为h的树的节点数目
                            S(h) = 1 + S(h - 1) + S(h - 2)  // 不是一般性，设左子树的高度为h-1,设右子树的高度为h-2,满足适度平衡，跟节点需要+1，则节点数量有如此关系
                            上等式左右各加一有：
                            S(h)+1 = [S(h - 1) + 1] + [S(h - 2) + 1]
                            有：
                            T(h) = T(h-1) + T(h-2)
                            是斐波那契数列的特征，可以断定等于某一项，只需考虑边界情况即可
                            高度h  规模n  T(h)
                            0      1      2=fib(3)
                            1      2      3=fib(4)
                            都知道斐波那契数列呈指数级别增长，即AVL树的规模随着高度呈指数级别增长。反过来logn也就构成了h的上界，也就是AVL适度平衡的要求       
            关键点2：一整套重平衡的技巧和算法
                失衡与重平衡：
                    a.插入一个节点，有可能会导致若干个祖先节点失衡；除了祖先节点之外的其他节点是不可能失衡的，无论是其还是其后代的平衡因子都不会发生变化；
                    
                    b.删除一个节点，有可能会导致其父节点失衡；对于删除操作来说，删除节点的瞬间至多只有一个结点会失衡；
                        如果删除某一个节点，父节点失衡了，那么删除的节点必定是在较短的分支，而决定父节点高度的是较长的分支，由于父节点高度未改变，所以只有可能是父节点失衡
        关系图：
        CBT ⊂ BBST ⊂ BST
            CBT:complete binary tree
            BBST:balanced binary search tree 
            BST:binary search tree
        | |  | CBT| | |
        | |  |__ _| | |
        | |  BBST   | |
        | |__ __ __ | |
        |     BST     |
        |__ __ __ __ _| 
    定义：
        又称为AVL tree(Adelson-Velskii and Landis)，两位俄国科学家的名字简称。
        一颗平衡二叉树或者是空树，或者是具有下列性质的二叉排序树（binary sort tree）:
            1)左子树与右子树的高度之差的绝对值小于等于1；
                高度：空树的高度是0，只有根节点的树的高度为1
            2)左子树和右子树也是平衡二叉排序树；
        补充：
            a.为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差，称之为该结点的平衡因子(BF)。
                结点BF = 结点左子树的高度 - 结点右子树的高度；
            b.根据平衡二叉树的定义，结点的平衡因子只能是:-1, 0, 1；可以用于检验是否是平衡二叉树。
            c.对于一颗有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL(average search length)也保持在O(log2n)数量级。
    
    失衡二叉排序树的分析与调整：
        失衡：
            当我们在一颗平衡二叉排序树上插入一个结点时，有可能导致失衡，即有一个或多个结点的平衡因子绝对值大于1的情况出现；
            当出现失衡情况，则必须调整树的结构，使之恢复平衡。
        
        平衡调整的类型：根据失衡原因进行分类
            结点A:失衡结点，由于结点C为根的子树插入新的结点，而失衡的结点；失衡的结点只存在于新插入结点的祖先结点中，与其他节点无关；不止一个失衡结点时，为最小失衡子树（结点数最少的失衡子树，即离新插入结点距离最近的祖先结点为根的子树）的根结点
            结点B:A结点的孩子，C结点的双亲
            C结点:将要插入新结点的子树的根结点，通常呢，C结点是一颗空树
            共四种，形如：结点A与结点B垂直投影在水平线后，A点与B点的距离绝对值是4个空格；同理，规定B结点和C结点垂直投影在水平线后，B点与C点的距离绝对值是2个空格(规定动机：根据二叉排序树定义可知，结点A、B、C的大小顺序为：
            结点A、B、C垂直投影到水平线上后，从左到右是递增的序列，如LL型投影后的大小顺序为C<B<A)。
                        A           A           A           A
                    B           B                   B           B
                  C               C               C               C
                    LL型         LR型             RL型         RR型
            说明：
                LL型：插入前，结点A平衡因子为+1；插入后，平衡因子为+2；于是A结点失衡
                RR型：插入前，结点A平衡因子为-1；插入后，平衡因子为-2；于是A结点失衡
                同理...
            补充：
                删除结点 失衡的结点只可能是其祖先结点，但至多一个祖先结点失衡
                    证明：若删除某一个结点后，距离最近的某个祖先结点Q失衡了，那么删除的结点必然在祖先结点Q的较短的子树分支，决定祖先结点Q的高度的是祖先结点Q较长的子树分支，于是不可能继续向上影响第二个祖先结点失衡，因为祖先结点Q的深度保持不变。
                插入结点 失衡的结点只可能是其祖先结点，几乎所有的祖先同时失衡
                注意是可能，就是存在删除 插入后不出现失衡结点， 删除至多存在一个失衡结点  插入至多存在祖先个数个失衡结点
                备注：尽管删除至多一个祖先失衡，但删除操作比插入操作更难。
                
        调整原则：
            1)降低高度：将高度从3降低为2
            2)保持二叉排序树性质：结点左孩子值小于结点值，结点右孩子值大于结点值
        四种失衡类型形态调整：各种失衡类型调整后正确结果仅有一种
                    A           A           A           A
                B           B                   B           B
              C               C               C               C
                LL型         LR型             RL型         RR型    
                ∨∨         ∨∨             ∨∨         ∨∨  
                B             C               C             B                             
            C       A     B       A       A       B     A       C
    操作
        插入：单旋(一次旋转后即恢复平衡)：LL型或RR型
            同时可有多个失衡节点，最低者g不低于新插入节点x的祖父
            g经过单旋调整后复衡，子树g高度复原，更高祖先也必平衡，全树复衡
            示例1：g:grandparent vertex, p:parent vertex, v:vertex, x:a new vertex will be inserted
                1)失衡：新节点X插入于T2或T3后失衡
                g                         <=<失衡,复衡>=>           p          
                    p                                           g       v                                                        
                        v                                                                                                         
              T0                                                      T2  T3                                                      
                  T1  T2  T3                                  T0  T1  X                                                          
                      X                                                                                     
                2)复衡：围绕失衡子树根节点g进行一次逆时针zag(g)旋转——BST等价变换
                    步骤：
                        a.引入一个临时引用rc，指向节点p;
                        b.让节点p的左子树T1成为节点g的右子树；
                        c.让节点g成为节点p的左孩子；
                        d.将局部子树的根由节点g替换为节点p，即p成为该子树新的根节点;
                        f.临时引用rc退出历史舞台，调整结束。
        插入：双旋(两次旋转后即恢复平衡)：LR型或RL型
            同时可有多个失衡节点，最低者g不低于新插入节点x的祖父
            g经过单旋调整后复衡，子树g高度复原，更高祖先也必平衡，全树复衡
            示例2：
                1)失衡：新节点X插入于T1或T2后失衡
                g                           <=<失衡,复衡>=>             v                                                                             
                        p                                           g       p                                        
                    v                                                 T1  T2                                  
              T0                                                  T0  X       T3                                                                      
                  T1  T2  T3    
                  X
                2)复衡：围绕节点p进行一次顺时针zig(p)旋转后再进行逆时针zag(g)旋转——BST等价变换
                    步骤：
                        a.引入一个临时引用lc，指向节点v;
                        b.让节点v的右子树T2成为节点p的左子树；
                        c.让节点p成为节点v的右孩子；
                        d.让节点v成为节点g的右孩子；
                        此时zig(p)旋转完成，紧接着节点g进行一次zag(g)旋转
                        e.让节点v的左子树T1成为节点g的右子树；
                        f.让节点g成为节点v的左孩子；
                        g.将局部子树的根由节点g替换为节点v，即v成为该子树新的根节点;
                        至此zag(g)旋转完成
                        h.临时引用lc退出历史舞台，调整结束。
        删除：单旋(一次旋转后即恢复平衡)：LL或RR型
            同时 至多一个失衡节点g,首个可能就是要删除节点d的父亲_hot
            g经过单旋调整后复衡，子树的高度未必复原；更高的祖先仍可能失衡；
            因有失衡传播现象，可能需要O(log(n))次调整；
            如下情形：
                删除前：结点a或b至少存在一个，节点c可能存在也可能不存在，节点d是要删除的节点；节点g的平衡因子是+1
                删除后：删除节点d后，节点g的平衡因子是+2，于是节点g失衡
                节点g经过zig(g)顺时针旋转后：若节点c存在，子树调整前后的高度一致，因此祖先节点也恢复平衡；若节点c不存在，调整后子树高度比之前低了1，更高祖先节点可能失衡（如某更高的祖先Q的平衡因子是-1，且调整后高度降低子树位于其左子树，则Q节点失衡）
                            g                 节点g经过zig(g)顺时针旋转后有：               p                                                                                  
                        p                                                              v       g                                                                        
                    v         T3                                                     T0  T1                                                               
                  T0  T1  T2  d                                                      a   b   T2  T3                                
                  a   b   c                                                                  c       
        删除：双旋(一次旋转后即恢复平衡)：LR或RL型
            同时 至多一个失衡节点g,首个可能就是要删除节点d的父亲_hot
            因有失衡传播现象，可能需要O(log(n))次调整；
            如下情形：
                删除前：结点p或q至少存在一个，节点r是要删除的节点；节点g的平衡因子是+1
                删除后：删除节点r后，节点g的平衡因子是+2，于是节点g失衡
                节点p经过zag(p)逆时针旋转后：依旧失衡，节点g的平衡因子是+2
                节点g经过zig(g)顺时针旋转后：恢复平衡，节点v的平衡因子是0，同之前删除前相比高度降低1，因此造成失衡传播
                        g          节点p经过zag(p)逆时针旋转后：           g               节点g经过zig(g)顺时针旋转后：          v                                                                                                 
                p                                                     v                                                      p       g                    
                    v     T3                                      p     T2  T3                                                 T1  T2               
              T0  T1  T2  r                                         T1  q                                                  T0  p   q   T3          
                  p   q                                         T0  p                                                                             
        插入/删除：3+4重构：单旋或双旋算法优化
            实际上，针对AVL树所介绍的插入和删除的单旋式或双旋式调整技巧，无非是为了形成对算法的理解；在真正实现时，大可不必这样实现。
            复衡重构步骤：
                a)设g(x)为最低的失衡节点，考察祖孙三代：g ~ p ~ v, 按 中序 遍历次序，将其命名为：a < b < c
                b)它们总共拥有互不相交的四棵（可能为空）子树，按 中序 遍历次序，将其重命名为：T0 < T1 < T2 < T3
                c)依然按照 中序 遍历次序，将a)和b)步骤的两个序列混合起来，就可以得到一个长度为7的序列
                    在这序列中，3个节点a,b,c必然镶嵌于这4棵子树T0,T1,T2,T3之间。
                    因此我们可以统一地将3个顶点a,b,c以及这4棵子树T0,T1,T2,T3，按照如下的拓扑关系直接拼接起来：
                            b
                        a       c
                      T0  T1  T2  T3   
                    具体来说：
                        将a 和c 分别作为b的左孩子和右孩子；
                        将T0和T1分别作为a的左子树和右子树；
                        将T2和T3分别作为b的左子树和右子树；
            这样一种拼接是针对于3个顶点和以及节点下属的4棵子树而言，所以也称之为3+4重构。
            特点：
                无论是插入或是删除，无论是单旋还是双旋，都是如此一个拓扑关系；
                能更加简明高效，能更加鲁棒安全的来实现相应的重构算法；
                        
        总结：
            调整后树高度height(p)等于失衡前树高度height(g)，于是更高祖先也必平衡，全树复衡；否则，将有失衡传播现象；
            等价变换原则：3+4重构的精髓
                1)降低高度：将高度从3降低为2
                2)保持二叉排序树性质：结点左孩子值小于结点值，结点右孩子值大于结点值
    综合评价：
        优点：
            a)无论查找、插入或删除，最坏情况下的 理论 复杂度均为O(logn)；
            b)O(n)的存储空间；
        缺点：
            a)借助高度或平衡因子，为此需要改造元素结构，或额外封装==>引入splay tree伸展树
            b)实测复杂度与理论值尚有差距：
                插入/删除后的旋转，成本不菲；若需频繁的插入删除，未免得不偿失
                    删除操作后，最多需要旋转logn次；（knuth：100次操作出现21次删除旋转（包括最坏的删除旋转情况））
            c)单次动态调整后，全树拓扑结构的变化量可能高达logn，这是最致命的缺陷，有严格要求；==>引入红黑树
                insert O(1)
                remove O(logn)
            
