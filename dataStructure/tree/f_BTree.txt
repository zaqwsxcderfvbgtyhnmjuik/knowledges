/// this is a topic about B tree，full name called balanced tree ///
    背景 
        从严格意义上讲，B树并不是一棵二分查找树，很快会看到，在物理上，B树的每一个节点都可能包含多个分支；
        从逻辑意义上讲，B树依然等效于之前所介绍的二分查找树BST，因此归类于高级搜索树；
    动机
        B树最初最主要的功能在于 弥合 不同存储级别之间在访问速度上的巨大差异，也就是实现高效的I/O。
        640K ought to be enough for anybody 
                                        - B. Gates, 1981
    越来越小的内存
        系统存储容量的增长速度 << 应用问题规模的增长速度
            亦即，绝对而言，内存的容量是在不断增大；相对而言，内存的容量是在不断减小
        为什么不把内存做得更大？
            物理上，存储器的容量大/小，访问速度就慢/快
    
    高速缓存
        事实1：不同容量的存储器，访问速度差异悬殊；
            a)以磁盘与内存为例：ms/ns > 10^5
                亦即，一次内存访问需要一秒，则一次外存访问就相当于一天；
            b)为避免1次外存访问，我们宁愿访问内存10次，100次，甚至...
            c)多数存储系统，都是分级组织的————Caching
                最常用的数据尽可能放在更高层、更小的存储器中；
                实在找不到，才向更低层、更大的存储器索取；
                如：CPU RAM <=I/O=> DISK ARRAY
                    需尽可能减少磁盘IO次数
        事实2：从磁盘中读写1B，与读写1KB几乎一样快；
            批量式访问：以页（page）或块（block）为单位，使用缓冲区的；
                如RAM <= pages => DISK
                
    B树结构
        每个节点有多个分支；
        所有底层节点的深度是完全一致的，是理想平衡的搜索树；
        相对于二叉排序树，B树更宽更矮；
        插入/删除会进行拓扑结构调整；
    
    多路平衡
        1970, R. Bayer & E. McCreight 定义B树为平衡的多路（multi-way）搜索树；
        若干个二路节点搜索树节点，经适当合并，得超级节点：
            每两代合并：4路分支，4-1个关键码（双亲节点+左右孩子节点共三个关键码）
            每三代合并：8路分支，8-1个关键码
            ...
            每d代合并：m = 2^d路分支, m-1个关键码
            如下图：共5个超级节点，每个超级节点4路分支（4个出度），3个关键码
                                *                      <=转换前|转换后=>           * * *            
                              *   *                             
                  *       *           *        *                        * * *  * * *  * * *  * * * *
                *   *   *   *       *   *    *   *  
    引入B树的原因
        逻辑上与BBST完全等价，为何还要引入B树呢？
            多级存储系统中使用B树，可针对外部查找，大大减少I/O次数
        难道，AVL树还不够？若有n=1G个记录存储于外存，对其构建AVL搜索树
            每次查找需要 log2(10^9) = 30次I/O操作，每次操作只读出一个关键码，得不偿失
        B树又如何？
            充分利用外存对批量访问的高效支持，将此特点转化为优点
            每下降一层，都以超级节点为单位，读入一组关键码
        具体多大一组？视磁盘的数据块大小而定，m = keys / page_size
            比如，目前多数数据库系统采用m=200~300
        回到上例，若取m=256，则每次查找只需log256(10^9)=4次 I/O
    
    B树定义
        深度统一 ：
            m阶B树，即m路平衡搜索树（m>=2）
            叶子节点 的深度同一相等
            外部节点 的深度同一相等
            树高h = 外部节点的深度
        阶次含义：
            内部节点各有：
                不超过m-1个关键码: K1 < k2 < ... < kn
                不超过m个分支:A0 < A1 < A2 < ... < An
            内部节点的分支树n+1也不能太少，具体地：
                树根：  2  <= n + 1 ; 即根节点至少有两个分支
                其余：⌈m/2⌉ <= n + 1
            故亦称作(⌈m/2⌉, m)树，
                如(4, 8)树，(4, 7)树，(3, 6)树，(2, 4)树
                (2, 4)树与红黑树密切联系
    B树实现：
        节点定义：
            template <typename T> struct BTNode { // B树节点
                BTNodePosi<T> parent; // 父
                vector<T> key; // 数值向量
                vector<BTNodePosi<T> > child; // 孩子向量（其长度总比key多1）
                BTNode() :parent(NULL) {child.insert(0, NULL);}
                BTNode(T e, BTNodePosi<T> lc = NULL, BTNodePosi<T> rc = NULL)  {
                    parent = NULL; key.insert ( e ); //作为根节点只有一个关键码，以及
                    child.insert ( lc ); if ( lc ) lc->parent = this; //左孩子
                    child.insert ( rc ); if ( rc ) rc->parent = this; //右孩子
                }
        B树定义：            
            template <typename T> class BTree { //B-树模板类
            protected:
               int _size; //存放的关键码总数
               int _m; //B-树的阶次，至少为3——创建时指定，一般不能修改
               BTNodePosi<T> _root; //根节点
               BTNodePosi<T> _hot; //BTree::search()最后访问的非空（除非树空）的节点位置
               void solveOverflow ( BTNodePosi<T> ); //因插入而上溢之后的分裂处理
               void solveUnderflow ( BTNodePosi<T> ); //因删除而下溢之后的合并处理
            public:
               BTree ( int m = 3 ) : _m ( m ), _size ( 0 ) //构造函数：默认为最低的3阶
               { _root = new BTNode<T>(); }
               ~BTree() { if ( _root ) release ( _root ); } //析构函数：释放所有节点
               int const order() { return _m; } //阶次
               int const size() { return _size; } //规模
               BTNodePosi<T> & root() { return _root; } //树根
               bool empty() const { return !_root; } //判空
               BTNodePosi<T> search ( const T& e ); //查找
               bool insert ( const T& e ); //插入
               bool remove ( const T& e ); //删除
            }; //BTree
    
    B树操作：
        查找：
            B树存放的词条（包含key和value）的数量极多，以至于不便完全容纳于内存中，甚至根本不能由内存容纳；假定存储于速度更慢的外存中。
            查找诀窍：只载入必需的节点到内存中，尽可能减少I/O操作
            步骤：
                从外存中磁盘IO读入B树根节点，节点内部顺序查找，查找成功返回，查找失败后，磁盘IO通过引用读取下一层的某个节点，继续查找，成功返回，直到下一个节点是外部节点，则查找以失败告终；
            结论：失败查找必终止于外部节点。
        插入：
            
                
        
            
