/// this is a topic about query of tree table

/// 背景
  线性表的查找方式有线性查找，二分查找，区间查找等方式，当线性表插入、删除操作频繁时，为维护线性表的有序性，需要移动表中很多记录。
    只作"查询"(检索)操作的查找表，定义为静态查找表。
  进而改用动态查找表——在静态查找表的基础上，作"插入"、"删除"操作的查找表，即树表——几种特殊的树
    表结构在查找的过程中动态生成：对于给定的key,若表中存在，则成功返回；否则，插入关键字等于key的记录
    
  
一、二叉排序树(alias:二叉搜索树或二叉查找树):Binary sort tree
    // 定义：
        二叉排序树或是空树，或是满足如下性质的树：
          a)若其左 子树 非空，则左子树上所有结点的值均 小于     根结点的值；
              归纳可得，等价于每个结点的左 孩子 小于 结点值；
          b)若其右子树非空，则右子树上所有结点的值均 大于等于 根结点的值；
              归纳可得，等价于每个结点的右 孩子 大于等于 结点值；
          c)其左右子树本身又是一颗二叉排序树<==>嵌套定义
    
    // 性质
        二叉排序树中序遍历序列是递增(不是严格递增)有序序列。
    
    // 存储结构
        typedef struct {
            KeyType key;// 记录关键字项
            InfoType otherinfo;// 记录数据项
        }ElemType;
        
        typedef struct BSTNode {
            ElemType data;  // 数据域
            struct BSTNode *lchild, *rchild; // 左右孩子指针
        }NSTNode, *BSTree;
        
    // 操作
        查找：
          算法思路：
            若二叉排序树为空，则查找失败，返回空指针（根结点地址）
            若二叉排序树非空，将给定值key与根结点的关键字T->data.key进行比较：
              a.若key等于T->data.key，则查找成功，返回根结点地址；
              b.若key小于T->data.key；则进一步查找左子树
              c.若key大于T->data.key；则进一步查找右子树
          
          算法描述：
            BSTree SearchBST(BSTree T, KeyType key) {
                if ( T==NULL )
                    return NULL;
                if ( key==T->data.key )
                    return T;
                    
                if ( key < T->data.key )
                    return SearchBST(T->lchild, key);
                if ( key > T->data.key ) // 同算法思路保持一致
                    return SearchBST(T->rchild, key);
            }
           算法分析：
              1)含有n个结点的二叉排序树的 平均查找长度(ASL) 和 树的形态有关
                最好情况：形态比较均衡，树的深度为⌈log2(n)⌉，平均查找长度(ASL)=log2(n+1)-1;同二分查找中的判定树相同，记为O( log2(n) )// ASL还未进行推导
                最坏情况：单支树的形态，树的深度为n，平均查找长度(ASL)=(n+1)/2;同顺序查找相同，记为O( n )// ASL还未进行推导,但好推导
              2)问题：如何提高形态不均衡的二叉排序树的查找效率？
                解决办法：做"平衡化"处理，即尽量让二叉树的形状均衡
        插入：
          算法思路：
            若二叉排序树为空，则插入结点作为根结点插入到空树中
            若二叉排序树非空，进行查找左右子树：
              a.若key等于T->data.key，则不再插入；
              b.若key小于T->data.key；则进一步查找左子树
              c.若key大于T->data.key；则进一步查找右子树
          
          算法描述：
            void InsertBST(BSTree T, NSTNode &newNode) {
                if ( T==NULL )
                    T = new NSTNode(newNode); // 得自己new，外界传入的newNode由外界管理释放等
                if ( &newNode->data.key==T->data.key )
                    return; // 已经插入，不再插入
                    
                if ( key < T->data.key )
                    return InsertBST(T->lchild, newNode);
                if ( key > T->data.key ) // 同算法思路保持一致
                    return InsertBST(T->rchild, newNode);
            }
            
          算法分析：
            1)插入的结点一定是在叶子结点上，无需移动其他记录；
            2)二叉排序树的生成，从空树出发，经过一序列插入操作之后，可生成一颗二叉排序树；
              a.一个无序序列通过生成二叉排序树而变成一个有序序列，其生成过程就是对无序序列进行排序的过程；
              b.关键字的输入顺序不同，建立的不同二叉排序树(百分之百不同)；
              
          
        删除：
          要求：
            1)保证删除后所得的二叉树仍然满足二叉排序树的性质不变；
              a)将因删除结点而断开的二叉链表重新链接起来
              b)防止重新链接后树的高度增加
              
          算法思路：
            情况0：被删除的结点DelNode未在树中，直接删除失败
            情况1：被删除的结点DelNode是叶子结点，则直接删去该结点；
            情况2：被删除的结点DelNode只有左子树或者只有右子树，则用其左子树或右子树替换它（结点替换）
            情况3：被删除的结点DelNode既有左子树又有右子树，则
                    a)以DelNode中序前驱结点值交换(值互换)，然后再删除该前驱结点(删除的情景是不可能为情况3，于是情况3不可能递归)。前驱结点是左子树中值最大的结点；
                        DelNode的前驱结点查找：前驱结点是左子树中值最大的结点，即从左子树根节点出发，一直找到最右侧结点，就是左子树中值最大结点；
                          参考后继结点。
                        DelNode的前驱结点删除：
                          参考后继结点。
                    b)以DelNode中序后继结点值交换(值互换)，然后再删除该后继结点(删除的情景是不可能为情况3，于是情况3不可能递归)。后继结点是右子树中值最小的结点；
                        DelNode的后继结点查找：
                          后继结点是右子树中值最小的结点，刚开始处，subsequentNode是DelNode->rchild，subsequentNodeParent是DelNode，接着subsequentNode一直找到最左侧结点，并记录subsequentNodeParent，就得到右子树中值最小结点，即DelNode后继结点；
                        DelNode的后继结点删除：
                          若subsequentNodeParent==DelNode，则subsequentNodeParent->rchild = subsequentNode->rchild，否则subsequentNodeParent->lchild = subsequentNode->rchild。接着释放DelNode后继结点subsequentNode即可。
              
          算法描述：
            bool EraseBST(BSTree& T, KeyType key) { // 传入的指针是引用是关键，删除叶子结点等时，可以对应将父节点相应的孩子指针置为空
                if ( T==NULL ) // case0
                    return false;
                    
                if ( key==T->data.key ) {// key is found 
                    if ( T->lchild==NULL && T->rchild==NULL ) { // case1
                        delete T;
                        T = NULL;
                        return true;
                        }

                    if (T->lchild!=NULL && T->rchild==NULL) { // case2
                        BSTree Nodedrop = T;                        
                        T = T->lchild;
                        delete Nodedrop; Nodedrop = NULL;
                        return true;
                        }

                    if (T->lchild==NULL && T->rchild!=NULL) { // case2
                        BSTree Nodedrop = T;
                        T = T->rchild;
                        delete Nodedrop; Nodedrop = NULL;
                        return true;
                        }

                    if (T->lchild!=NULL && T->rchild!=NULL) { // case3
                        // look the subsequent node(后继结点) in middle order and its parent                                                
                        BSTree subsequentNode = T->rchild; ///< subsequent at the beginning 
                        BSTree subsequentNodePareant = T;
                        
                        while ( subsequentNode&&subsequentNode->lchild ) {
                            subsequentNodePareant = subsequentNode;
                            subsequentNode = subsequentNode->lchild;
                            }

                        // swap rightSubTreeLeftestNode->data and T->data
                        ElemType temp = T->data;
                        T->data = subsequentNode->data;
                        subsequentNode->data = temp;

                        // delete rightSubTreeLeftestNode with case2 or case1
                        ( subsequentNodePareant==T ? subsequentNodePareant->rchild : subsequentNodePareant->lchild) = subsequentNode->rchild ;
                        
                        delete subsequentNode;
                        subsequentNode = NULL;

                        return true;
                        }
                    }
                    
                // key is still in query processing
                if ( key < T->data.key )
                    return EraseBST(T->lchild, key);
                if ( key > T->data.key ) // 同算法思路保持一致
                    return EraseBST(T->rchild, key);
            }
          
          算法分析：
            情况3的删除有可能降低二叉排序树的高度，但不会增加树的高度；
            BST变种颇多，此文只是一种实现，不要局限于此
          
        
二、平衡二叉排序树:Binary balanced sort tree
    背景：
        问题：二叉排序树最坏情况下的ASL是(n+1)2,退化到同线性表线性查找一个级别；这是一个有待解决的客观问题。
        解决方法：做"平衡化"处理，即尽量让二叉树的形态平衡。
    
    定义：
        又称为AVL tree(Adelson-Velskii and Landis)，两位俄国科学家的名字简称。
        一颗平衡二叉树或者是空树，或者是具有下列性质的二叉排序树（binary sort tree）:
            1)左子树与右子树的高度之差的绝对值小于等于1；
                高度：空树的高度是0，只有根节点的树的高度为1
            2)左子树和右子树也是平衡二叉排序树；
        补充：
            a.为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差，称之为该结点的平衡因子(BF)。
                结点BF = 结点左子树的高度 - 结点右子树的高度；
            b.根据平衡二叉树的定义，结点的平衡因子只能是:-1, 0, 1；可以用于检验是否是平衡二叉树。
            c.对于一颗有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL(average search length)也保持在O(log2n)数量级。
    
    失衡二叉排序树的分析与调整：
        失衡：
            当我们在一颗平衡二叉排序树上插入一个结点时，有可能导致失衡，即有一个或多个结点的平衡因子绝对值大于1的情况出现；
            当出现失衡情况，则必须调整树的结构，使之恢复平衡。
        
        平衡调整的类型：根据失衡原因进行分类
            结点A:失衡结点，由于结点C为根的子树插入新的结点，而失衡的结点；失衡的结点只存在于新插入结点的祖先结点中，与其他节点无关；不止一个失衡结点时，为最小失衡子树（结点数最少的失衡子树，即离新插入结点距离最近的祖先结点为根的子树）的根结点
            结点B:A结点的孩子，C结点的双亲
            C结点:将要插入新结点的子树的根结点，通常呢，C结点是一颗空树
            共四种，形如：结点A与结点B垂直投影在水平线后，A点与B点的距离绝对值是4个空格；同理，规定B结点和C结点垂直投影在水平线后，B点与C点的距离绝对值是2个空格(规定动机：根据二叉排序树定义可知，结点A、B、C的大小顺序为：
            结点A、B、C垂直投影到水平线上后，从左到右是递增的序列，如LL型投影后的大小顺序为C<B<A)。
                        A           A           A           A
                    B           B                   B           B
                  C               C               C               C
                    LL型         LR型             RL型         RR型
            说明：
                LL型：插入前，结点A平衡因子为+1；插入后，平衡因子为+2；于是A结点失衡
                RR型：插入前，结点A平衡因子为-1；插入后，平衡因子为-2；于是A结点失衡
                同理...
            补充：
                删除结点 失衡的结点只可能是其祖先结点，但至多一个祖先结点失衡
                    证明：若删除某一个结点后，距离最近的某个祖先结点Q失衡了，那么删除的结点必然在祖先结点Q的较短的子树分支，决定祖先结点Q的高度的是祖先结点Q较长的子树分支，于是不可能继续向上影响第二个祖先结点失衡，因为祖先结点Q的深度保持不变。
                插入结点 失衡的结点只可能是其祖先结点，几乎所有的祖先同时失衡
                注意是可能，就是存在删除 插入后不出现失衡结点， 删除至多存在一个失衡结点  插入至多存在祖先个数个失衡结点
                备注：尽管删除至多一个祖先失衡，但删除操作比插入操作更难。
                
        调整原则：
            1)降低高度：将高度从3降低为2
            2)保持二叉排序树性质：结点左孩子值小于结点值，结点右孩子值大于结点值
        四种失衡类型形态调整：各种失衡类型调整后正确结果仅有一种
                    A           A           A           A
                B           B                   B           B
              C               C               C               C
                LL型         LR型             RL型         RR型    
                ∨∨         ∨∨             ∨∨         ∨∨  
                B             C               C             B                             
            C       A     B       A       A       B     A       C
            
三、红黑树:Red black tree

四、B树:B tree

五、B+树:B plus tree

六、键树:Key tree
