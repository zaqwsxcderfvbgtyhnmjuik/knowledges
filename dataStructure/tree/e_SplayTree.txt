/// this is a topic about splay tree 伸展树 ///

伸展树
    局部性：
        locality:刚被访问过的数据，极有可能 很快地 再次被访问 之一现象在信息处理过程中屡见不鲜。
        例子：
            BST：刚刚被访问过的节点，极有可能很快地 再次被访问，下一将要访问的节点，极有可能就在刚被访问过节点的附近。
        提出问题：
            连续的m次查找（m >> n = |BST|）,采用AVL共需O(mlogn)时间，利用局部性能否更快？
    
    自适应调整：
        list/array：将刚访问的元素移到head之前，称为新的head,以更好的被下一次访问到；
        BST：借助list/array的自适应调整，将刚刚访问的元素移动到树根，即降低深度，以便于更好的被下一次访问到；是否可行？具体如何实现？
    
    逐层伸展：
        定义：节点v一旦被访问，随即转移至树根；
        实现手段：为了实现这一目标，我们所能借助的手段，依然无非是此前所介绍过的等价变换；具体来说就是对节点v进行zig和zag变换，如下：
            如果节点v在当前这一层是左孩子，我们就通过对它的父亲节点p做一次 顺时针zig旋转，使得二者在高度上彼此互换；
                           zig(p)           ==>             zigged
                            p                                 v
                          v   Z                             X   p 
                        X   Y                                 Y   Z   
            对称的，如果节点v在当前这一层是右孩子，我们就通过对它的父亲节点p做一次 逆时针zag旋转，使得二者在高度上彼此互换；
                         zagged             <==              zag(p)
                           v                                  p                                                
                         P   Z                              X   v
                       X   Y                                  Y   Z  
            总而言之，无论是经过一次zig还是zag旋转，对应的节点v都可以在高度上上升一层，既然如此，我们不妨反复地使用这一技巧，是v的高度逐层上升，直到最终抵达树根，成为BST树新的树根节点。
        
        一步一步往上爬：
            自下而上，逐层单旋
                zig(v->parent)
                zag(v->parent)
            直到v节点最终被推送至根，成为新的树根节点
        
        最坏情况：
            考虑如下一棵结点数为n的左单支树，
                                g
                              f  
                            e
                          d
                        c
                      b
                    a  
            依次查询节点a,b,c,d,e,f,g，有如下过程：
                查询节点a：
                    关键码比较次数：n次
                    查询后树结构调整为：
                              a       
                                g
                              f  
                            e
                          d
                        c
                      b
                查询节点b：
                    关键码比较次数：n-1次
                    查询后树结构调整为：
                              b
                            a  
                              g
                            f  
                          e
                        d
                      c
                ...
                查询节点f：
                    关键码比较次数：3次
                    查询后树结构调整为：
                              f  
                            e   g
                          d
                        c
                      b
                    a  
                查询节点g：
                    关键码比较次数：2次
                    查询后树结构调整为：
                                g 
                              f  
                            e   
                          d
                        c
                      b
                    a                 
            经过一轮查询后，树拓扑结构回到了第一次查询前的树形拓扑结构；旋转次数呈 周期性的算术级数演变：每一周期累计O(n^2)，分摊每一次查询时间是O(n)。已经退化成了最原始的线性序列。
                好消息是问题的根源本身不在于伸展本身，而是在于我们没有把它运用好，那么如何改进呢？————画龙点睛
        
    双层伸展：改进最坏情况，画龙点睛的一笔
        为伸展树这条龙，点上那只传神之眼的是著名计算机科学家Tarjan;
        D. D. sleator & R. E. Tarjan
            Self-Adjusting Binary Trees
        J. ACM, 32:652-686, 1985

        构思的精髓：向上追溯两层，而非一层
            反复考察祖孙三代：g = parent(p), p = parent(v), v
            根据它们的相对位置，经两次旋转使得v上升两层，成为(子)树根
                 zigzig         zigzag      zagzag       zagzig
                   g              g           g            g
                 p              p               p            p
               v                  v               v        v   

        子孙异侧：zigzag或zagzig <==从g到p，p在g左侧称zig；p在g右侧称zag  <左zig右zag> 补充：<zig顺时针zag逆时针>
            与AVL树双旋完全等效！
            与逐层伸展别无二致！
            如zigzag情形调整：
                    g           zig(p)==>               g               zag(g)==>            v                                                                                         
                  W   p                               W   v                               g     p                                   
                    v   Z                               X   p                           W   X Y   Z                                     
                  X   Y                                   Y   Z                                                               

        子孙同侧：zigzig或zagzag
            祖孙三代 逐层调整：过程->非常熟悉，平淡无奇
                    g           zig(p)==>               g               zig(g)==>            v   
                  p   Z                               v   Z                                W   g                                           
                v   Y                               W   p                                    p   Z                                                    
              W   X                                   X   Y                                X   Y                                                                        

            祖孙三代 画龙点睛：过程->越级从祖父节点g开始旋转，即经过祖父节点的一次顺时针zig旋转；节点p和v都会上升一层；接下来，对新的树根也就是p节点，再做一次zig顺时针旋转，使得v继续上升一层，成为局部子树的根节点
                    g           zig(g)==>               p               zig(p)==>            v                           
                  p   Z                              v     g                               W   p     
                v   Y                              W   X Y   Z                               X   g                
              W   X                                                                            Y   Z                           
        每一次画龙点睛的过程，不但将v升高两层（距离树根最后一步，可能只上升一层），并且可能降低该步调整前的近一半的树高，树高产生折叠效应。
            折叠效果：一旦访问坏节点，对应路径的长度将随即 减半；// 含羞草
                    使得最坏的情况不再 发生！ 
                    单趟伸展操作，分摊O(logn)时间！

        最后一步：
            要是v只有父亲，没有祖父
            此时必有parent(v) == root(T),且每轮调整中，这种情况至多（在最后）出现一次
            视具体形态，做单次旋转：zig(r)或rag(r)；
            这种情况在整个伸展的过程中，只会出现一次，因此从渐进的意义而言，并不会实质的影响整个调整过程的复杂度。
        至此，Targin的调整建议，这种双层调整的策略不仅是完备的，而且是行之有效的。
                    
    接口定义：
        template <typename T> class Splay : public BST<T> { //由BST派生的Splay树模板类
        protected:
           BinNodePosi<T> splay ( BinNodePosi<T> v ); //将节点v伸展至根
        public:
           BinNodePosi<T> & search ( const T& e ); //查找（重写）==>是一种动态操作，举足轻重
           BinNodePosi<T> insert ( const T& e ); //插入（重写）
           bool remove ( const T& e ); //删除（重写）
        };
                      
    动态操作：
        查找算法：///<是一个动态操作，是与其他BBST的本质区别
            内部查找+双层调整，详见上述。
        
        插入算法：
            直观方法：调用BST标准的插入算法，再将新节点伸展至根；
                其中，首先需调用BST::search()
            
            更优方法：
                重写后的Splay::search()已集成了splay()操作，查找(失败)之后，_hot即是根节点；我们的新节点本来就应该作为_hot的左或右孩子接入树中的，既然_hot已经让根节点唾手可得，就不用费经周折地去做更复杂的操作。        
                步骤：
                    调用Splay::search()接口，不是一般性，查找是失败的并且记失败前最终那个节点为t，也就是之前所说的_hot，接下来，集成在Splay::search()内部的splay()操作，自然将节点t伸展至树根，如下图所示：
                            t
                        TL     TR  
                    从逻辑上，将整棵树在t位置上一分为二，比如将t与其右子树分离开，如图所示：
                            t 和 TR
                        TL     
                    引入节点v，并且将t以及其后代 作为v的左子树；而原先从t处分离出来的子树将作为v的右子树重新接入这课树中
                其效果与通常的插入完全一样，具体来说，不仅使得一个新节点得以顺利插入树中，而且同样使它于树根的位置，就像它曾经被伸展上去一样。    
                      
        删除算法：
            直观方法：调用BST标准的删除算法，再将_hot节点伸展至根节点，成为新的树根节点。
            
            更优方法：
                重写后的Splay::search()已集成了splay()操作，查找(成功)之后，目标节点即是树根节点；
                既如此，何不随即就在树根附近完成目标节点的摘除...
                步骤：
                    调用Splay::search()接口，对待删除的节点进行定位，不是一般性，不妨假设查找成功，接下来，集成在Splay::search()内部的splay()操作，自然将待删除节点v伸展至树根
                    释放掉待删除的节点v，剩下TL和TR两棵子树
                    合并TL和TR子树：
                        若TR为空，TL则是余树；
                        若TR不空，在TR中再次查找v：注定失败，但其中的最小节点m必伸展至根（且无左孩子），节点m相对于TL来说，它确是最大者，故可令其以TL作为左子树;不仅完成拓扑结构的连接，而且能保证所有元素的中序遍历次序。                            
                      
    综合评价：
        1)无需记录节点高度或平衡因子；编程实现简单易行——优于AVL树。
            分摊复杂度O(logn)——与AVL树相当。
        2)局部性强、缓存命中率极高时（即k << n << m）///< 比如你用电脑的过程往往就是这样，尽管你的硬盘上所存放的文件、数据等等是数以万计或者几百万记，但是在很短的时间内，你所经常使用的数据往往就是其中非常低的百分比。
            效率甚至可以更高——自适应的O(logk)
            任何连续的m次查找，都可以O(mlogk + nlogn)时间内完成     
        3)任然不能保证单次最坏情况的出现，不适用于对单次操作效率十分敏感的场合；
            伸展树的形状，在任何时候，通常都是不平衡的，甚至是极其不平衡的；因此我们完全可能在某一个不幸的时刻，需要访问一个足够深，甚至最深的节点；尽管伸展树在此后会随即将这条路径缩短至将近一半，但是在此前的这次查找过程中你不得不仍需付出沉重的代价。                  
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
