/// this is a topic about binary tree ///

// 1.背景
    为什么要研究树，难道此前研究的vector和list不够用吗？
                                    vector          list       ( tree )
        静态操作：search             √               ×          ( √ )
        动态操作：insert/delete      ×               √          ( √ )
        由此可见，无论是向量还是列表，都无法兼顾动态操作和静态操作的同时高效性，而如何将二者又是结合起来，就是研究树的目的，
        同时，也没错，根据得出的结论是tree能够将二者结合起来。
	为何研究二叉树，不研究其他树，是否失去一般性？
        二叉树结构最简单，规律性最强；
        可以证明，所有树都能转为唯一对应的二叉树，不是一般性；同时也可以还原回去；
        普通树(多叉树)，若不转化成为二叉树，则运算很难实现
        所以不失一般性！
        
// 2.树的定义
    树是一种半线性结构；
    树是特殊的图T = (V, E), 节点数|V| = n,边数|E| = e
    有根树
        指定任一节点r ∈ V作为根后，T即称作为有根树(rooted tree)
        若：T1, T2,..., Td为有根树
            则：T = ( (∪Vi) ∪ {r}, (∪Ei) ∪ {<r,ri> | 1 <= i <= d } )也是
            相对于T, Ti称作以ri为根的子树(subtree rooted at ri),记作Ti = subtree(ri)
         即：                 r
                          ↙  ↓  ↘
                       r1 ... rk ... rd
    有序树：定义兄弟间的次序
        ri称作r的孩子(child),ri之间互称兄弟(sibling)
        r为其父亲(parent)，d = degree(r)为r的(出)度(degree)
        可归纳证明：
            e = ∑r∈V degree(r) = n - 1 
            用处：告诉我们任何一棵树的边数与顶点的数目是同阶的，在此后讨论时间复杂度以顶点个数来讨论。
        若指定Ti为作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树(ordered tree)
    
    路径或通路
        路径：V中的k+1个节点，通过E中的k条边依次相连，构成一条路径(path)
            π = { (v0, v1), (v1, v2), ......, (vk-2, vk-1), (vk-1, vk) }
            即：
            v0——v1——v2 ······ vk-1——vk
        路径长度：|π| = 边数 = k // 算法描述更简单
        
    环路(cycle/loop)：vk = v0
        即：
        v0——v1——v2 ······ vk-1——vk——v0
    
    连通+无环=树：
        连通：节点之间均有路径，称作连通图(connected graph)
        无环：不含有环路(acyclic graph)
        树：无环连通图 或 极小连通图 或 极大无环图 // 三者等价
        故：
            任一节点v与根节点之间存在唯一路径
                path(v, r) = path(v) // 由于根节点(特定指定)唯一，所以可以舍去   
   
    深度+层次
        不致歧义时，路径、节点和子树可相互指代
            path(v) ~ v ~ subtree(v)
                path from root to v = path(v)
                subtree rooted at v = subtree(v)
        v节点的深度：
            1)depth(v) = |path(v)|
                体现了任何一个节点v从根节点开始，向下深入的程度
            2)path(v)上的结点，均为v的祖先(ancestor),v是它们的后代(descendent)
                其中，除自身外，是真(proper)祖先/后代。
            3)根节点是所有节点的公共祖先，深度为0
            4)没有后代的节点称作叶子(leaf)：叶子节点必然存在，是有限集合
                所有叶子深度最大者，称为(子)树(根)的高度。
                    height(v) = height(subtree(v))
                    特别的：
                        只有1个节点的树的高度是0；
                        只有0个节点的树的高度是-1；// 非常自然的设计
                        depth(v) + height(v) <= height(T)
                            何时取等号？
                                当且仅当v节点在最长路径上时，等号成立；且是充要条件
        半线性：在任一深度，v的祖先/后代若存在，则必然/未必唯一

// 3.树的逻辑表示
    父节点表示
    孩子节点表示
    父节点+孩子节点表示
    长子+兄弟表示：
        对于任何一个节点，只需记录两个简明的引用长子和兄弟
            垂直方向：纵：firstChild()
            水平方向：横：nextSibling()
         不仅是一种树的很好的逻辑表示，而且是对树的本质的更深刻的理解。   
            基于该表示法，可以用二叉树来基于某些规则后表示/描述所有的树   
                保证有根性
                保证有序性
// 4.二叉树(binary tree)：有根有序节点出度不超过2的树
    定义：
        1)是n(n>=0)个结点的有限集，它或者是空集（n==0）,或者由一个根结点及两颗互不相交的分别称为这个根的左子树和右子树的二叉树组成。
        2)二叉树是有根树
        3)节点度数不超过2的树，故称作二叉树(binary tree)
        4)同一节点的孩子和子树，均以左、右区分，隐含有序(习惯地认为左在先右在后)，二叉树是有序树
            lChild() ~ lSubtree()
            rChild() ~ rSubtree()
    基数：
        1)深度为k的节点，至多2^k个;
        2)含n个节点、高度为h的二叉树中，满足：h < n < 2^(h+1)
            a.若n=h+1时，退化为一条单链；
            b.若n=2^(h+1)-1时，即所谓的满二叉树(full binary tree)
            c.对于二叉树，长宽是指数级，长高是对数级
    特点：
        每个结点至多两个孩子（二叉树中不存在度大于2的结点）
        子树有左右之分，其次序不能颠倒；
            注意: 二叉树不是树的特殊情况，它们是两个概念
	    		二叉树的子树要区分左子树和右子树，即使只有一颗子树也要区分，说明是左子树还是右子树；
				树当结点只有一个孩子时，就无需区分它是左还是右的次序，因此二者是不同的，这是树与二叉树最主要的差别；
			    即二叉树的左右子树与树的有序性的区别；
        二叉树可以是空集，根可以有空的左子树或空的右子树；

// 5.描述多叉树：如何通过二叉树来描述多叉树(一般意义上的树)
    1)二叉树是多叉树的特例，但二叉树在有根且有序时，其描述能力却足以覆盖多叉树。
        a.将多叉树以长子兄弟法表示
        b.将每一个结点的firstChild、nextSibling顺时针旋转45°后，就是一颗二叉树
    2)因此将对树的研究转换为其特例二叉树的研究
    
// 6.二叉树的五种基本形态
    空二叉树
    根和空的左右子树
    根和左子树
    根和右子树
    根和左右子树
    
// 7.二叉树性质
    性质1：在二叉树的第i层上至多有2^(i-1)个结点（i>=1）;
        补充：在二叉树的第i层上至少有一个结点，否则该层就不存在了；
    性质2：深度为k的二叉树至多有2^k - 1个结点（k>=1）;
        补充：深度为k的二叉树至少有k个结点（k>=1）;
    性质3：对任何一棵二叉树T,如果叶子结点数为n0,度为2的结点数n2,则n0=n2+1
        证明：
        设总边数为Edges，结点数量为n，
            从下往上看，显而易见除了根节点向上无边后，其余结点均有一个边指向双亲，于是Edges = n-1;
            从上往下看，显而易见度为2的结点向下发出2条边，度为1的结点向下发出1条边，度为0的结点向下发出0条边，于是Edges = n2*2 + n1*1;
            于是得n=n2*2 + n1*1 + 1
            有因为n=n2+n1+n0
            于是有n0 = n2 + 1
        证明完成
        
// 8.满二叉树
    定义：一个深度为k且有2^k - 1个结点的二叉树。
    特点：
        1.每一层上的结点数都是最大结点数；
        2.叶子结点全部在最底层
        3.对满二叉树从上到下从左至右从1进行编号，每一个编号对应的结点位置都有元素；
        
// 9.完全二叉树
    定义：深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，称之为完全二叉树。
    特点：
        1.叶子结点可能分布在层次最大的两层上；
        2.对任一结点，如果其右子树的最大层次为i,则其左子树的最大层次必为i或i+1;
        3.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树；
        
// 10.完全二叉树性质
    性质4：具有n个结点的完全二叉树的深度为⌊log2(n)⌋+1;表明了完全二叉树结点数n与完全二叉树深度k之间的关系。
        注意：⌊x⌋:称作x的底，表示不大于x的最大整数
        证明：假设此完全二叉树的深度为k，则根据二叉树的性质2及完全二叉树的定义能够得到：
            2^(k-1) - 1 < n <=2^k - 1
            放缩后表示为：
            2^(k-1) <= n <2^k
            两边取对数有：
            k-1 <= log2(n) < k
            有因为k是整数，所以有：
            k=⌊log2(n)⌋ + 1
            
    性质5：如果对一棵有n个结点的完全二叉树（深度为⌊log2(n)⌋+1）的结点按层序编号（从第一层到第⌊log2(n)⌋+1层，每层从左到右），则对任一结点i(1<= i <=n)有：
        1) 如果i=1,则结点i是完全二叉树的根，无双亲;如果i>1,则双亲结点是⌊i/2⌋      
        2) 如果2i>n,则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
        3) 如果2i+1>n,则结点i无右孩子；否则，其右孩子是结点2i+1
        证明：结论的编号从1开始，证明从下标编号0开始，实际线性存储时，根节点存储在下标为0的数组开头处：
            进而转换为证明：如果父亲结点的下标为k,则左孩子的下标为2k+1(k=0,1,2,...)
            设父亲结点k为f层第m个(f=0,1,2... ;m=0,1,2...),则k=2^f + m - 1
                思路：
                    数组的长度为L,则最后一个元素的下标为L-1;
                    第0,1,...,f-1层共有2^f - 1个结点，又在f层的第m个，于是该数组的长度为2^f - 1 + m + 1个，即2^f + m个，最后一个元素就是父亲结点k，下标为k==2^f + m - 1
            其左孩子结点kL的位置关系，分析可得：
                父亲结点k前面有m个结点，由完全二叉树的定义得到，其左孩子结点kL前面就有2m个结点，进而得到kL位置为f+1层的第2m+1个结点：
                于是计算从根节点到kL结点，包含根节点和kL结点共有多少个结点，即数组的长度：2^(f+1)-1 + 2m + 1,即2^(f+1) + 2m,进而其kL结点的编号下标为2^(f+1) + 2m - 1
            至此，通过比较k和kL的编号下标不难得出：
                kL=2k+1
            进一步，k的右孩子的编号下标为：
                kR=2k+2
            进一步，反过来，从孩子节点编号下标到双亲结点下标为：
                左孩子：k=⌊kL/2⌋
                右孩子：k=⌊kR/2⌋-1
                总结起来：
                k=⌊(kL-1)/2⌋=⌊(kR-1)/2⌋
                即
                k=⌊(孩子下标-1)/2⌋
                    
 // 11.二叉树存储结构：结点定义
        顺序存储结构
            实现：按满二叉树的结点层次从上到下从左到右从0开始递增1编号，依次按照编号从小到大从数组下标为0处逐个存放二叉树中的数据元素；
                亲子位次关系，参照性质5
            表示：
                #define MAXSIZE 100
                typedef elemType SqBiTree[MAXSIZE]; //binary tree
                SqBiTree bt;
            分析：
                数组长度固定，对于二叉树元素数量变化较大的情形不适合，适合数量较为稳定的二叉树。（浪费空间）
                数组长度固定，对于稀疏二叉树不适合，适合完全或满二叉树。（浪费空间）
                
        链式存储结构
            二叉链表：
                实现：将一对多的关系进行从前往后地串起来。
                表示：
                    typedef struct BiNode {
                        elemType data;
                        struct BiNode *lchild, *rchild;// 左右孩子指针
                    }BiNode, *BiTree;
            
                分析：
                    一对多的关系从前往后串起来，适合遍历寻找孩子节点情形；
                    在n个结点的二叉链表中，有n+1个空指针区域；
                    证明：
                        n个结点，每个结点两个指针域，则必有2n个指针域；
                        从结点到根反向看，除根节点外，每个结点的前驱都只有一个连线指向双亲，即共有n-1个指针域被使用；
                        未使用的指针域则是空指针域数量：2n - (n - 1)，即n+1个空指针域；
            三叉链表：
                实现：将一对多的关系进行从前往后、从后往前地串起来。
                表示：
                    typedef struct BiNode {
                        elemType data;
                        struct BiNode *lchild, *parent, *rchild;// 左双亲右孩子指针
                    }TriNode, *TriTree;// trinary tree 
            
                分析：
                    一对多的关系从前往后，从后往前串起来，适合往前寻找孩子双亲节点情形；
                    
// 12.二叉树遍历
    遍历
        定义：
            顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅仅被访问一次（又称周游）。
            注意：
                访问的含义较广，可以是对结点作各种处理，如输出，比较，修改，但要求这种访问不破坏原来的数据结构（不插入、删除结点）；
        目的：
            得到树中所有结点的一个线性排列。
        用途：
            是增删改查和排序运算的前提，是二叉树的一切运算的基础和核心。
            前缀中缀后缀表达式分别对于先序中序后序遍历，可以进行表达式转换操作。
            计算表达式值。
            构建语法树。
            排序树。
            ...
            依据先序中序或后序中序遍历，确定唯一一棵二叉树。
    
    先中后遍历    
        方法：
            依次遍历二叉树的三个组成部分，便是遍历整个二叉树，假设L:遍历左子树，D:遍历根节点，R:遍历右子树，则遍历的方案根据全排列可得6种：DLR,LDR,LRD,DRL,RDL,RLD，
            规定先左后右，则只有前三种情况，见分类。
        
        分类：
            DLR——先（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)访问根结点
                        2)先序遍历左子树
                        3)先序遍历右子树
                算法实现：
                    void preOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        visit(T);
                        preOrderTraverse(T->lchild);
                        preOrderTraverse(T->rchild);
                    }
            LDR——中（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)中序遍历左子树
                        2)访问根结点
                        3)中序遍历右子树
                算法实现：
                    void midOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        midOrderTraverse(T->lchild);
                        visit(T);
                        midOrderTraverse(T->rchild);
                    }
            LRD——后（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)后序遍历左子树
                        2)后序遍历右子树
                        3)访问根结点
                算法实现：
                    void postOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        postOrderTraverse(T->lchild);
                        postOrderTraverse(T->rchild);
                        visit(T);
                    }
        分析：
            如果去掉visit(T)语句，从递归的角度看，三种算法是完全相同的，或者说这三种算法的访问路径是相同的，只是访问结点的时机不同；
            从虚线的出发点到终点的路径上，每个结点经过三次,即执行线与每个结点共同在同一个作用域下3次；（↗↘↖↙）
                第1次经过时访问==先序遍历；不访问时，使用栈记录起该结点；
                第2次经过时访问==中序遍历；不访问时，使用栈记录起该结点；
                第3次经过时访问==后序遍历；不访问时，使用栈记录起该结点；
                           A
                      ↙↗   ↘↖
                    ↙B↖      ↘C↖
                   ↙↗↘↖   ↙↗↘↖

            时间复杂度：O(n) <==> 每个结点访问一次，n个结点访问n次
            空间复杂度：o(n) <==> 最坏情况下，一棵树单侧树，需要记录最多n个结点，所以是O(n)
           
    层次遍历：
        定义：
            对于一棵二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点；每个结点只访问一次。
        算法描述：
            使用一个队列；
            将根结点进队；
            队列不空时循环：从队列中出列一个结点P，访问它；
                若它有左孩子结点，将左孩子结点进队；
                若它有右孩子结点，将右孩子结点进队；
        
        算法实现：
            队列使用std标准库队列queue
            void levelOrderTraverse(BiTree T) {
                std::queue<BiTree> levelQueue;
                levelQueue.push(T); // 将根结点进队
                while( !levelQueue.empty ( ) ) {    // 队列不空时循环：
                    BiTree p = levelQueue.front();  // 从队列中出列一个结点P，访问它
                    visit(p);
                    
                    if (p->lchild) levelQueue.push(p->lchild);  // 有左孩子时将其入队
                    if (p->rchild) levelQueue.push(p->rchild);  // 有右孩子时将其入队
                    levelQueue.pop();   // 可以在front()后面紧接着就调用，pop不会调用pop出来的对象的析构函数，因此紧接着就调用也可以继续使用pop出来的p
                }
            }
                
    // 13.遍历运用
        要求：按照先序遍历序列（空节点使用#代替，如ABC##DE#G##F###）建立二叉树的二叉链表。
        算法实现：
            // 主体实现
            void createBiTree(BiTree &T) {
                char ch = '#';
                std::cin>>ch;
                if (ch=='#') T = NULL;
                else {
                    if (T = new BiNode)
                        exit(-1);
                    T->data = ch;
                    createBiTree(T->lchild); // 递归创建左子树 
                    createBiTree(T->rchild);
                }
            }
            
            // 调用逻辑
            BiTree root;
            createBiTree(root);
        
        要求：复制二叉树
	    算法思路：
            如果是空树，算法结束；
            否则
                申请新结点空间，复制根结点
                递归复制左子树
                递归复制右子树
             
        算法实现：
            int CopyBiTree(BiTree T, BiTree &NewT) {
                if ( T==NULL ) {
                    NewT = NULL;
                    return 0;
                }
                else {
                    NewT = new BiTNode();
                    NewT->data = T->data;
                    CopyBiTree( T->lchild, NewT->lchild );
                    CopyBiTree( T->rchild, NewT->rchild );
                }
                
            }
        
        要求：计算二叉树深度
        算法思路：
            如果是空树，则深度为0;
            否则
                递归计算左子树的深度记为m;
                递归计算左子树的深度记为n;
                且二叉树的深度为m和n较大者加1;
        算法实现：
            int Depth(BiTree T) {
                if ( T==NULL ) return 0;
                int m = Depth( T->lchild );
                int n = Depth( T->rchild );
                return max(m, n) + 1;
            }
         
         要求：计算二叉树的结点数
         算法思路：
            如果是空树，则结点个数是0；
            否则
                递归计算左子树的结点个数m；
                递归计算右子树的结点个数n；
                且二叉树的结点个数为m+n后再加1;
         算法实现：
            int nodeCount( BiTree T ) {
                if ( T==NULL ) return 0;
                int m = nodeCount(T->lchild);
                int n = nodeCount(T->rchild);
                return m+n+1;
           }
           
         要求：计算二叉树叶子结点个数
         算法思路：
            如果是空树，则叶子结点个数为0；
            否则
                递归计算左子树的叶子结点数为m;
                递归计算右子树的叶子结点数为n;
                且二叉树的叶子结点数为m+n;

         算法实现：
            int leafNodeCount(BiTree T) {
                if ( T==NULL ) return 0;                            ///< 如果是空树返回0
                if ( T->lchild==NULL && T->rchild==NULL ) return 1; ///< 如果是叶子结点返回1
                int m = leafNodeCount(T->lchild);   ///< T是一棵树，再分别去统计左子树的叶子结点数和右子树的结点数
                int n = leafNodeCount(T->rchild);
                return m+n;
                
            }
    
    // 14.插入与删除
    	删除一个结点，只能在叶子结点处，否则一颗满二叉树插入/删除一个非叶子结点，那么就不再是一颗二叉树了。
        插入一个结点，只能在叶子结点处，否则一颗满二叉树插入/删除一个非叶子结点，那么就不再是一颗二叉树了。
        删除一课子树，可以在所有结点处，即删除以该结点为根的子树
        插入一课子树，只能在叶子结点处，即插入以该结点为双亲的子树
        
           
           
           
           
           
           
           
           
           
            
