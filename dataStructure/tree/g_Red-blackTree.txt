/// this is a topic about red-black tree ///

红黑树(red black tree):BBST家族中的又一新成员。
    动机：
        1)ephemeral structure:
            回顾之前所学的数据结构，无论是：
                线性结构：向量、列表、栈、队列
                半线性结构：树
                非线性结构：图
            都呈现这么一种特征：每当经过一次动态的操作，使得其中的逻辑结构发生变化之后，都会随即完全转入新的状态，同时将此前的状态完全地遗忘掉，这些数据结构也因此称为ephemeral structure.
                它们都是随时变化的，每一个状态只会存在于某一个瞬间，而每一个瞬间都是朝生暮死，稍纵即逝，然而在实际运用中，往往可能会有更高的要求。
        2) persistent structure:一致性结构 或 持久化结构
            静态动态操作都支持对历史版本的访问。
                T.search(ver, key); T.insert(ver, key); T.remove(ver, key);
            蛮力实现：
                每个版本独立保存；各版本入口自成一个搜索结构（如线性数组的二分查找），如：
                ver_0        ver_1        ...                 ver_n
                a            x                                x                            
              b               c                                 v
                  c                                               w
                单次操作：O(logh + logn)，累计O(h*n)时间/空间.  // h = |history|
                    时间可以接受，但空间绝对不能接受的。
                挑战：可否将空间复杂度控制在：O(n + h*logn)内？
                    n是所有元素各自所占用的空间
                    logn是每一个历史版本所消耗的均摊空间量，h*logn是所有历史版本所消耗的空间量。
                可以：为此需利用相邻版本之间的关联性...
            O(1)重构：大量元素共享，少量元素更新：每个版本的新增复杂度，仅为O(logn)
                能否进一步提高，比如总体O(n+h)、单历史版本O(1)？
                    可以
                为此，就树形结构的拓扑而言，相邻版本之间的差异不能超过O(1)
                    然而，很遗憾，绝大多数的BBST，包括此前的AVL树，都不能保证这一点。
                    所谓的拓扑结构差异无非是来自调整过程中的旋转操作，每一次局部的旋转都意味着在结构上引入常数的差异。
                    因此，反过来，如果需要保证前后版本在拓扑结构上的差异不超过常数，也就意味着，在从前一版本转入后一版本的过程中，所执行的旋转操作不得超过常数次。
                    因此，反观AVL树的两个动态操作，插入操作是满足这一条的（一旦经过一次旋转，全树的高度都会复原）；然而很可惜，删除操作并非如此（从AVL树中，删除一个节点之后，有可能自底而上，引发有可能多大logn次的旋转，从而导致树形拓扑结构的剧烈变化。）
                    因此，为了使得上述构思能够兑现，我们就需要这样一种BBST，它的任何动态操作，无论插入还是删除，对树形拓扑结构的影响都能控制在常数的范围内，即引发的结构变化量不致超过O(1)。
                    而红黑树，正是具有这一特性的BBST的一个变种。 
    结构：定义规则
        历史脉络：
            1972, R.Bayer, "symmetric binary B-tree"
            1978, L.Guibas & R.Sedgewick, "red-black tree"
            1982, H.Olivie, "half-balanced binary search tree "
            分别从不同角度定义了红黑树，只讲解其中一种
        规则：
            由红、黑两类节点组成的BST // 亦可给边染色
                补充：便于讲解，甚至实现红黑树，对红黑树的模型做一个小小的扩充：统一增设外部节点NULL，使得其中的结点都有两个孩子（叶子节点就增加两个空孩子），使之成为真二叉树，此时内部节点都有两个孩子。
                示例： 
                    补充 外部结点^ 前：
                            a
                                b
                              c   
                    补充 外部结点^ 后：
                            a
                        ^       b
                              c   ^
                            ^   ^  
            概括：4句话
                1)树根(如果红黑树非空)：必为黑色；
                2)刚刚扩充的外部结点：均为黑色；
                3)其余节点：若为红，则只能有黑孩子；// 红之子、之父必黑=>对于控制 红黑树深度 极其重要
                4)外部节点到根：途中黑节点数目相等；// 黑深度=>控制红黑树的 平衡性
    
    (2, 4)树==红黑树            
        提升各红节点，使之与其(黑)父亲等高（提升变换）————于是每棵红黑树，都对应于一棵(2, 4)树
        将黑节点与其红孩子视作（关键码并合并为）超级节点...
        无非四种组合，分别对应于4阶B树的一类内部节点 // 反过来呢？
        如图所示：
                                    黑黑                 黑红                 红黑                    红红
        提升后红黑树：               
                                     B                 B --> R              R <-- B                R <-- B --> R                                         
                                  B     B           B     B     B        B     B     B          B     B     B     B       
                                                                                              
        视作超级节点：
                                     B                 B-----R              R-----B                R-----B-----R          
                                  B     B           B     B     B        B     B     B          B     B     B     B  
        注意：
            1)-->或<--：表示由黑父亲指向红孩子
            2)-----：表示黑父亲和其提升后的红孩子合并为超级节点
            3)黑黑是黑父亲的两个孩子都是黑色的节点，同理黑红指的是黑父亲的两个孩子，左孩子是红色节点，右孩子是黑色节点，同理...
    
    接口定义：
        template <typename T> class RedBlack : public BST<T> { //RedBlack树模板类
            protected:
               void solveDoubleRed ( BinNodePosi<T> x ); //双红修正
               void solveDoubleBlack ( BinNodePosi<T> x ); //双黑修正
               int updateHeight ( BinNodePosi<T> x ); //更新节点x的高度（重写）
            public:
               BinNodePosi<T> insert ( const T& e ); //插入（重写）
               bool remove ( const T& e ); //删除（重写）
            // BST::search()等其余接口可直接沿用
            };
                                                                                                    
        
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
