/// this is a topic about red-black tree ///

红黑树(red black tree):BBST家族中的又一新成员。
    动机：
        1)ephemeral structure:
            回顾之前所学的数据结构，无论是：
                线性结构：向量、列表、栈、队列
                半线性结构：树
                非线性结构：图
            都呈现这么一种特征：每当经过一次动态的操作，使得其中的逻辑结构发生变化之后，都会随即完全转入新的状态，同时将此前的状态完全地遗忘掉，这些数据结构也因此称为ephemeral structure.
                它们都是随时变化的，每一个状态只会存在于某一个瞬间，而每一个瞬间都是朝生暮死，稍纵即逝，然而在实际运用中，往往可能会有更高的要求。
        2) persistent structure:一致性结构 或 持久化结构
            静态动态操作都支持对历史版本的访问。
                T.search(ver, key); T.insert(ver, key); T.remove(ver, key);
            蛮力实现：
                每个版本独立保存；各版本入口自成一个搜索结构（如线性数组的二分查找），如：
                ver_0        ver_1        ...                 ver_n
                a            x                                x                            
              b               c                                 v
                  c                                               w
                单次操作：O(logh + logn)，累计O(h*n)时间/空间.  // h = |history|
                    时间可以接受，但空间绝对不能接受的。
                挑战：可否将空间复杂度控制在：O(n + h*logn)内？
                    n是所有元素各自所占用的空间
                    logn是每一个历史版本所消耗的均摊空间量，h*logn是所有历史版本所消耗的空间量。
                可以：为此需利用相邻版本之间的关联性...
            O(1)重构：大量元素共享，少量元素更新：每个版本的新增复杂度，仅为O(logn)
                能否进一步提高，比如总体O(n+h)、单历史版本O(1)？
                    可以
                为此，就树形结构的拓扑而言，相邻版本之间的差异不能超过O(1)
                    然而，很遗憾，绝大多数的BBST，包括此前的AVL树，都不能保证这一点。
                    所谓的拓扑结构差异无非是来自调整过程中的旋转操作，每一次局部的旋转都意味着在结构上引入常数的差异。
                    因此，反过来，如果需要保证前后版本在拓扑结构上的差异不超过常数，也就意味着，在从前一版本转入后一版本的过程中，所执行的旋转操作不得超过常数次。
                    因此，反观AVL树的两个动态操作，插入操作是满足这一条的（一旦经过一次旋转，全树的高度都会复原）；然而很可惜，删除操作并非如此（从AVL树中，删除一个节点之后，有可能自底而上，引发有可能多大logn次的旋转，从而导致树形拓扑结构的剧烈变化。）
                    因此，为了使得上述构思能够兑现，我们就需要这样一种BBST，它的任何动态操作，无论插入还是删除，对树形拓扑结构的影响都能控制在常数的范围内，即引发的结构变化量不致超过O(1)。
                    而红黑树，正是具有这一特性的BBST的一个变种。 
    结构：定义规则
        历史脉络：
            1972, R.Bayer, "symmetric binary B-tree"
            1978, L.Guibas & R.Sedgewick, "red-black tree"
            1982, H.Olivie, "half-balanced binary search tree "
            分别从不同角度定义了红黑树，只讲解其中一种
        规则：
            由红、黑两类节点组成的BST // 亦可给边染色
                补充：便于讲解，甚至实现红黑树，对红黑树的模型做一个小小的扩充：统一增设外部节点NULL，使得其中的结点都有两个孩子（叶子节点就增加两个空孩子），使之成为真二叉树，此时内部节点都有两个孩子。
                示例： 
                    补充 外部结点^ 前：
                            a
                                b
                              c   
                    补充 外部结点^ 后：
                            a
                        ^       b
                              c   ^
                            ^   ^  
            概括：4句话
                1)树根(如果红黑树非空)：必为黑色；
                2)刚刚扩充的外部结点：均为黑色；
                3)其余节点：若为红，则只能有黑孩子；// 红之子、之父必黑=>对于控制 红黑树深度 极其重要
                4)外部节点到根：途中黑节点数目相等；// 黑深度=>控制红黑树的 平衡性
    
    (2, 4)树==红黑树            
        提升各红节点，使之与其(黑)父亲等高（提升变换）————于是每棵红黑树，都对应于一棵(2, 4)树
        将黑节点与其红孩子视作（关键码并合并为）超级节点...
        无非四种组合，分别对应于4阶B树的一类内部节点 // 反过来呢？
        如图所示：
                                    黑黑                 黑红                 红黑                    红红
        提升后红黑树：               
                                     B                 B --> R              R <-- B                R <-- B --> R                                         
                                  B     B           B     B     B        B     B     B          B     B     B     B       
                                                                                              
        视作超级节点：
                                     B                 B-----R              R-----B                R-----B-----R          
                                  B     B           B     B     B        B     B     B          B     B     B     B  
        注意：
            1)-->或<--：表示由黑父亲指向红孩子
            2)-----：表示黑父亲和其提升后的红孩子合并为超级节点
            3)黑黑是黑父亲的两个孩子都是黑色的节点，同理黑红指的是黑父亲的两个孩子，左孩子是红色节点，右孩子是黑色节点，同理...
    
    接口定义：
        template <typename T> class RedBlack : public BST<T> { //RedBlack树模板类
            protected:
               void solveDoubleRed ( BinNodePosi<T> x ); //双红修正
               void solveDoubleBlack ( BinNodePosi<T> x ); //双黑修正
               int updateHeight ( BinNodePosi<T> x ); //更新节点x的高度（重写）
            public:
               BinNodePosi<T> insert ( const T& e ); //插入（重写）
               bool remove ( const T& e ); //删除（重写）
            // BST::search()等其余接口可直接沿用
            };
                                                                                                    
    动态调整算法：
        插入操作：
            与理解红黑树的定义一样，这里必须借助 B树的模型，才能更好的了解相关算法的原理及其过程。
            也就是说，我们在考察rb树的时候，在脑海中总是要有一棵对应的B树，后者就犹如前者的影子，时时刻刻相伴相随。
            与所有的BBST一样，在经过了动态变化之后，rb树的组成成员不仅发生了变化，而且它们之间的拓扑连接关系 也可能发生变化。
            很遗憾，这种变化通常并不容易直接理解，为此我们需要借助B树的影子，具体来说，也就是rb树在变换之前以及变换之后所对应的那棵B树
            即：
                rb-tree          B-tree
                   〇   →          〇   
                   |               ↓   
                   V                
                   ▢   ←          ▢
            步骤：
                1)现拟插入关键码e // 不妨设T中本不含e
                2)按BST的常规算法，插入之，生成一个末端节点X // X = insert(e)必为末端节点
                3)不妨设X节点的父亲P = X->parent 存在 // 否则,即平凡的首次插入
                4)将X染红（除非它是根节点）// X->color = isRoot(x) ? B : R
                    P--->X->parent，不知是何种颜色，可能黑可能红
                    X--->新插入的节点X染成红色
                  ^   ^--->外部节点默认一直是黑色
                    
                    此时，条件1) + 2) + 4)依然满足，但3)不见得，有可能...
                        a.如果节点P原本是黑色的，那么条件3)满足，整个插入操作结束；
                        b.如果节点P原本是红色的，比如这样一种拓扑：
                            g--->黑色
              颜色不定<---u p--->红色
                            x--->红色
                          ^   ^--->两黑色外部节点
                            ❶双红缺陷（double-red）：新插入的节点x与它的父亲同时为红色，这是红黑树规则所禁止的，这样一种非法的情况，也因此称作双红缺陷（double-red）// P->color == X->color == R
                            ❷如何修复这种双红缺陷呢？
                                我们来考查：x的祖父g = P->parent // g != null && g->color == B <==请注意此时的g是必然存在的，否则作为根节点的p是不可能为红色的，进一步的作为红色节点p的父亲，g必然是黑色的
                                            p的兄弟u = p == g->lc ? g->rc : g->lc // 即x的叔父，u节点的颜色是不定的
                                视u的颜色，分两种情况处理：
                                    RR-1：u->color == B == 黑色
                                        此时：x、p、g的四个孩子（可能是外部节点）全为黑，且黑高度相同。
                                        考虑zigzig和zigzag两种情况，其余两种情况对称,自行补充：
                                            zigzig:除了节点p、x，其余全是黑色节点     ==>红节点提升运动再合并为四叉超级节点：    ==>交换四叉超级节点中间key和右侧key的颜色，条件3)重新满足
                                                        g                                        x-----p-----g   <==RRB四叉节点            
                                            红色<---p       u                                 ^     ^     ^     u          
                                          红色<---x   ^   ^   ^                                               ^   ^
                                                ^   ^
                                            zigzag:除了节点p、x，其余全是黑色节点     ==>红节点提升运动再合并为四叉超级节点：    ==>交换四叉超级节点中间key和右侧key的颜色，条件3)重新满足
                                                        g                                        p-----x-----g   <==RRB四叉节点                           
                                            红色<---p       u                                 ^     ^     ^     u            
                                              红色<---x   ^   ^                                               ^   ^                  
                                                    ^   ^  
                                        ..................................虚线以上以rb树的影子(2,4)树阐述失衡后复横；虚线下则是从rb树自身出发进行复衡............................................................
                                        将另外两种情况也考虑进来，参照AVL树算法，做局部3+4重构
                                            将节点x,p,g及其四棵子树，按中序组合为：
                                                T0 < a < T1 < b < T2 < c < T3
                                                即：
                                                        b                                                                                                                   
                                                    a       c                                                                                                         
                                                 T0   T1 T2   T3                                                                                      
                                        染色：
                                            b转黑，a或c转红，即将居中的节点b染黑，其左右两个孩子染红（染色前：b是黑，a或c中一黑一红，但不确定谁是红）
                                        补充：从B树的角度，如何理解这一情况？
                                            整个调整过程以及效果，从B树的角度来看是非常清晰明了的；
                                            调整前之所以是非法，是因为
                                                在某个三叉节点中插入了一个红色的关键码（此时变成四叉节点），使得原黑关键码不再居中 // RRB或BRR，出现相邻的红关键码 
                                            调整之后的效果相当于 // B-树的拓扑结构不变，但
                                                在新的四叉节点中，三个关键码的颜色改为RBR
                                        红黑树的拓扑结构有所调整，但仅限于局部，是一撮而就的，无需任何进一步的调整，时间复杂度是O(1)
                                        注意：四叉节点是有四个分支树的节点。
                                        
                                    RR-2：u->color == R == 红色
                                        考虑zigzig和zigzag两种情况，其余两种情况对称,自行补充：
                                            zigzig:除了节点p、x、u，其余全是黑色节点     ==>红节点提升运动再合并为五叉超级节点：
                                                        g                                        x-----p-----g-----u   <==RRBR五叉节点            
                                            红色<---p       u--->红色                         ^     ^     ^     ^     ^     
                                          红色<---x   ^   ^   ^                                               
                                                ^   ^
                                            zigzag:除了节点p、x、u，其余全是黑色节点     ==>红节点提升运动再合并为五叉超级节点：
                                                        g                                        p-----x-----g-----u   <==RRBR五叉节点                           
                                            红色<---p       u--->红色                         ^     ^     ^     ^     ^       
                                              红色<---x   ^   ^                                                                
                                                    ^   ^  
                                        此时，与其说是在修复rb树的双红缺陷，不如说是在对应的4阶B树中修复上溢缺陷。这两者完全是一回事。
                                        以zigzag双红缺陷为例，对应的4阶B树上溢缺陷修复后如下所示：
                                                    ?-----g-----?                                                                                   
                                                 p-----x     u                        
                                               ^    ^    ^ ^   ^
                                            紧接着，在修复好上溢缺陷的拓扑中，进行颜色变换；其中g变成红色，p变成黑色，u变成黑色，以使zigzag且u->color==red情形的rb树结合提升变换得到的rb树影子(2,4)B树在刚刚解决上溢缺陷后间接符合rb树的规则3)，其逆提升变换得到的rb树就是一颗符合全部rb树规则的合法rb树。==>可以将此视为为什么rb树节点的颜色要进行如此变换的过程和原因。
                                            凑巧的是，经过上一句所示的颜色变换后得到的影子(2, 4)B树，逆提升变换后得到的已解决双红缺陷的rb树，等价于在原来具有双红缺陷的rb树中做一些节点前后颜色的改变，不需要发生节点拓扑结构的改变。
                                            g左右两侧的?至少有一个黑色的关键码，遗憾的是也可能有一个红色的邻居，进而再次导致双红缺陷的发生；即BRR或RRB
                                                双红缺陷无非就这两种，所以四个字如法炮制即可。
                                                或
                                                具体讲，再次导致的双红缺陷可能是RR-1：u->color==B或RR-2：u->color==R；
                                                    之前已经研究过RR-1：u->color==B，rb树解决双红缺陷，仅仅只需要经过一次拓扑结构调整、一次颜色变换，就完成，是O(1)的空间复杂度，O(1)的时间复杂度
                                                    刚研究的RR-2：u->color==R，rb树解决双红缺陷，仅仅只需要经过零次拓扑结构调整、至多logn次颜色变换，就完成，是O(1)的空间复杂度，O(logn)的时间复杂度。
            复杂度：
                解决插入操作产生的双红缺陷，重染色的次数可能会是logn，但拓扑结构的变化依然控制在O(1)常数的范围内。
                    即RR-2：u->color==R , ... , RR-2：u->color==R, RR-1：u->color==B(optional)就结束双红缺陷的修复。    
                    即其中：
                        至多做O(log)次节点染色；
                        至多做一次"3+4"节点拓扑重构；对于persistent structures是至关重要的！
        
        删除操作：
           相对于插入，rb树的删除算法情况更多，也更为复杂一些，因此更有必要借助提升变换将rb树映射为对应的(2,4)B树，并站在后者的角度反过来理解前者的过程及原理。当然更重要的是依然关注重构操作，无论是以下将要讨论的哪种情况，我们都不要忘了确认其对应的重构操作次数 都不超过常数。
               即rb树 <=——=> B树
           算法框架：
               A》首先按照BST常规算法，执行：
                   r = removeAt(x, _hot); // 返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲 ———— 二者均有可能是NULL
               B》x由孩子r接替；// 另一孩子记作w（即黑的NULL）
               C》条件1)和2)依然满足，但3)和4)不见得
                   a)若被删除者和实际被删除节点的接替者二者之一为红，则3)和4)不难满足
                       即简明地将替代者染为黑色即可
                       示例1：
                                               p--->黑色              删除x节点==>        p--->黑色         ==>所有的外部节点的黑深度保持不变，满足规则4)；规则3)不涉及
                                               x--->红色                                 r--->被染成黑色
                            黑色的NULL节点<---w   r--->黑色或外部节点 
                       示例2：
                                               p--->黑色              删除x节点==>        p--->黑色         ==>所有的外部节点的黑深度保持不变，满足规则4)；规则3)不涉及
                                               x--->黑色                                 r--->被染成黑色
                          黑色的NULL节点<---w       r--->红色                           ^   ^
                                                 ^   ^
                   b)双黑缺陷：以示例2删除x节点的图示进行(注意：将w节点重命名为s)
                       若x与r均黑，double-black，则上述a)的调整失效
                       摘除x并代之以r后
                           全树黑深度不再统一
                           原B树中x所属节点下溢
                       在新树中考察，考查：
                           r的父亲p = r->parent // 亦即原树中x的父亲
                       在原树中考察，考查：
                           r的兄弟s = r==p->lc ? p->lr : p->lc
                       考虑以下四种情况：
                           BB-1:s为黑，且至少有一个红孩子t；1,2,3,4是4棵子树,且黑高度一致;B节点表示一个黑节点
                               调整方法：
                                   3+4重构：t,s,p重命名为a,b,c；r保持黑;a和c染黑;b继承p的原色
                                   rb树调整前拓扑：黑高度一致为2
                                                          p                                     
                                              黑色<---s       x--->黑色                                     
                                            红色<---t   B     r--->黑色                                   
                                                  B   B 2     3                                   
                                                  0   1
                                   rb树调整后拓扑：黑高度一致为2
                                                        s                                                                            
                                            黑色<---t       p--->黑色                                                                           
                                                  B   B   B   x/r--->黑色
                                                  0   1   2    3
                                   如此，红黑树的性质在全局得以恢复————删除完成
                                   ........................以上是红黑树的基础上的节点拓扑调整、节点颜色变换；以下是用对应的B树来体会该调整的深刻原理.........................................................
                                                         BB-1               ==>          对应的影子(2,4)B树        ==>      影子(2,4)B树删除关键码x后旋转得    ==>等价对应到rb树得(即虚线以上的rb调整操作就一目了然)，即可得到在rb树基础上一种可行的调整方案    
                                                          p                                     ?-----p-----?                       ?-----s-----?                    s                  
                                              黑色<---s       x--->黑色                红色<---t-----s     x--->黑色            黑色<---t      p--->黑色    黑色<---t       p--->黑色                         
                                            红色<---t   B     r--->黑色                     B    B     B   r--->黑色                 B   B   B  r--->黑色        B   B   B   x/r--->黑色                           
                                                  B   B 2     3                            0    1     2   3                         0   1   2  3                0   1   2    3                                    
                                                  0   1                                   
                           
                           BB-2R:s为黑，且两个孩子均为黑；且p为红；1,2,3,4是4棵子树,且黑高度一致;B节点表示一个黑节点    
                               调整方法：
                                   颜色调整：r保持黑；s转红；p转黑 <==>在对应的B树中，等效于下溢节点与兄弟合并
                               ........................以上是红黑树的基础上的节点拓扑调整、节点颜色变换；以下是用对应的B树来体会该调整的深刻原理..........................
                                                      BB-2R                ==>          对应的影子(2,4)B树       ==>      影子(2,4)B树删除关键码x后合并得      ==>等价对应到rb树得(即虚线以上的rb调整操作就一目了然)，即可得到在rb树基础上一种可行的调整方案    
                                                        p--->红色                             ?-----p-----? --->p红色                ?-----?                        p--->黑色
                                              黑色<---s   x--->黑色                      黑色<---s     x--->黑色              红色<---s-----p--->黑色      红色<---s   x/r--->黑色 
                                                    B   B r--->黑色                           B   B   r--->黑色                   B    B    r--->黑色          B   B  2
                                                    0   1 2                                   0   1   2                           0    1    2                 0   1                      
                                   
                                   如此，红黑树的性质在全局得以恢复————删除完成                                                                                                                                                      
                                   失去关键码p后，在B树中，上层节点会否继而下溢？
                                       不会，因为关键码p是红色的，这就意味着在它所属的B树节点中，至少还应该有一个黑色的关键码（因为有B、BR、RB和RBR四种RB树节点和B树超级节点对应关系），还有一个黑色节点，(2,4)B树的该结点就不会继续上溢                                                                                                                                                                                         
                                       即合并之前，在p之左或右侧还应有（问号）关键码必为黑色，有且仅有一个                                                                                                                                                  
                           
                           BB-2B:s为黑，且两个孩子均为黑；且p为黑；1,2,3,4是4棵子树,且黑高度一致;B节点表示一个黑节点                                                                                                                                                              
                               调整方法：
                                   颜色调整：s转红；r和p保持黑
                               ........................以上是红黑树的基础上的节点拓扑调整、节点颜色变换；以下是用对应的B树来体会该调整的深刻原理..........................
                                                      BB-2B                ==>          对应的影子(2,4)B树       ==>      影子(2,4)B树删除关键码x后合并得      ==>等价对应到rb树得(即虚线以上的rb调整操作就一目了然)，即可得到在rb树基础上一种可行的调整方案    
                                                        p--->黑色                                   p--->黑色                          NULL                        p--->黑色
                                              黑色<---s   x--->黑色                      黑色<---s     x--->黑色              红色<---s-----p--->黑色      红色<---s   x/r--->黑色 
                                                    B   B r--->黑色                           B   B   r--->黑色                   B    B    r--->黑色          B   B  2
                                                    0   1 2                                   0   1   2                           0    1    2                 0   1                      
                                   
                                   如此，红黑树的性质在全局得以恢复————删除完成                                                                                                                                                      
                                   失去关键码p后，在B树中，上层节点会否继而下溢？
                                       会，失去唯一的p节点后，导致下层下溢 引发 上层下溢；至多会持续logn次，即至多下溢到根节点。
                           
                           BB-3:s为红，且两个孩子均为黑；且p为黑；1,2,3,4是4棵子树,且黑高度一致;B节点表示一个黑节点         
                               此类型不需要做实质的处理，只需转换成此前所处理的某两种类型即可；
                               调整方法：
                                   单旋+重染色：zag(p)或zig(p);红s转黑；黑p转红
                               ........................以上是红黑树的基础上的节点拓扑调整、节点颜色变换；以下是用对应的B树来体会该调整的深刻原理..........................
                                                      BB-3                  ==>          对应的影子(2,4)B树       ==>      影子(2,4)B树对调节点s和p的颜色      ==>等价对应到rb树得(即虚线以上的rb调整操作就一目了然)，即可得到在rb树基础上一种可行的调整方案    
                                                        p--->黑色                     红色<---s-----p--->黑色                黑色<---s-----p--->红色                        s--->黑色                                                                                              
                                              红色<---s   x--->黑色                         B   B     x--->黑色                    B   B     x--->黑色                    B   p--->红色                                                                                                                     
                                                    B   B r--->黑色                         0   1     r--->黑色                    0   1     r--->黑色                   0  B   x--->黑色                                                                                                                                            
                                                    0   1 2                                           2--->黑色                              2--->黑色                      1   r--->黑色
                                                                                                                                                                               2
                               得到转换后的rb树，若删除x节点后，黑高度依然异常，但转换并非没有意义
                                   节点r有了一个新的黑兄弟B，故转化为前述情况，而且p已经转红，接下来绝不会是情况BB-2B（父节点p为黑，且复杂度会不断向上下溢）,而只能是BB-1或BB-2R
                               于是，再经过一轮调整之后，红黑树的性质必然全局恢复。
                                                         
    总结：                               
        1)复杂度：
            红黑树的每一删除操作，都可在O(logn)时间内完成；
                其中至多做：
                    O(logn)次重染色
                    一次“3+4”重构
                    一次单旋
             表格：
                    情况                  旋转次数            染色次数            此后
                    (1)黑s有红子t         1~2                   3               调整后随即完成
                    (2R)黑s无红子,p红     0                     2               调整后随即完成 
                    (2B)黑s无红子,p黑     0                     1               必然再次双黑，但将上升一层
                    (3)红s               1                     2               转为(1)或(2R)                                            
        
        2)只需做一次"3+4重构"或单旋，这也是rb树优于AVL树的重要方面，这一特性对于持久性的实现是至关重要的！                                                          
                                                                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
