/// this is a topic about binary tree ///

// 背景
	为何研究二叉树，不研究其他树，是否失去一般性？
        二叉树结构最简单，规律性最强；
        可以证明，所有树都能转为唯一对应的二叉树，不是一般性；同时也可以还原回去；
        普通树(多叉树)，若不转化成为二叉树，则运算很难实现
        所以不失一般性！
        
// 二叉树定义
    是n(n>=0)个结点的有限集，它或者是空集（n==0）,或者由一个根结点及两颗互不相交的分别称为这个根的左子树和右子树的二叉树组成。
    
    特点：
        每个结点至多两个孩子（二叉树中不存在度大于2的结点）
        子树有左右之分，其次序不能颠倒；
            注意: 二叉树不是树的特殊情况，它们是两个概念
	    		二叉树的子树要区分左子树和右子树，即使只有一颗子树也要区分，说明是左子树还是右子树；
				树当结点只有一个孩子时，就无需区分它是左还是右的次序，因此二者是不同的，这是树与二叉树最主要的差别；
			    即二叉树的左右子树与树的有序性的区别；
        二叉树可以是空集，根可以有空的左子树或空的右子树；
        
// 二叉树的五种基本形态
    空二叉树
    根和空的左右子树
    根和左子树
    根和右子树
    根和左右子树
    
// 二叉树性质
    性质1：在二叉树的第i层上至多有2^(i-1)个结点（i>=1）;
        补充：在二叉树的第i层上至少有一个结点，否则该层就不存在了；
    性质2：深度为k的二叉树至多有2^k - 1个结点（k>=1）;
        补充：深度为k的二叉树至少有k个结点（k>=1）;
    性质3：对任何一棵二叉树T,如果叶子结点数为n0,度为2的结点数n2,则n0=n2+1
        证明：
        设总边数为Edges，结点数量为n，
            从下往上看，显而易见除了根节点向上无边后，其余结点均有一个边指向双亲，于是Edges = n-1;
            从上往下看，显而易见度为2的结点向下发出2条边，度为1的结点向下发出1条边，度为0的结点向下发出0条边，于是Edges = n2*2 + n1*1;
            于是得n=n2*2 + n1*1 + 1
            有因为n=n2+n1+n0
            于是有n0 = n2 + 1
        证明完成
        
// 满二叉树
    定义：一个深度为k且有2^k - 1个结点的二叉树。
    特点：
        1.每一层上的结点数都是最大结点数；
        2.叶子结点全部在最底层
        3.对满二叉树从上到下从左至右从1进行编号，每一个编号对应的结点位置都有元素；
        
// 完全二叉树
    定义：深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，称之为完全二叉树。
    特点：
        1.叶子结点可能分布在层次最大的两层上；
        2.对任一结点，如果其右子树的最大层次为i,则其左子树的最大层次必为i或i+1;
        3.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树；
        
// 完全二叉树性质
    性质4：具有n个结点的完全二叉树的深度为⌊log2(n)⌋+1;表明了完全二叉树结点数n与完全二叉树深度k之间的关系。
        注意：⌊x⌋:称作x的底，表示不大于x的最大整数
        证明：假设此完全二叉树的深度为k，则根据二叉树的性质2及完全二叉树的定义能够得到：
            2^(k-1) - 1 < n <=2^k - 1
            放缩后表示为：
            2^(k-1) <= n <2^k
            两边取对数有：
            k-1 <= log2(n) < k
            有因为k是整数，所以有：
            k=⌊log2(n)⌋ + 1
            
    性质5：如果对一棵有n个结点的完全二叉树（深度为⌊log2(n)⌋+1）的结点按层序编号（从第一层到第⌊log2(n)⌋+1层，每层从左到右），则对任一结点i(1<= i <=n)有：
        1) 如果i=1,则结点i是完全二叉树的根，无双亲;如果i>1,则双亲结点是⌊i/2⌋      
        2) 如果2i>n,则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
        3) 如果2i+1>n,则结点i无右孩子；否则，其右孩子是结点2i+1
        证明：结论的编号从1开始，证明从下标编号0开始，实际线性存储时，根节点存储在下标为0的数组开头处：
            进而转换为证明：如果父亲结点的下标为k,则左孩子的下标为2k+1(k=0,1,2,...)
            设父亲结点k为f层第m个(f=0,1,2... ;m=0,1,2...),则k=2^f + m - 1
                思路：
                    数组的长度为L,则最后一个元素的下标为L-1;
                    第0,1,...,f-1层共有2^f - 1个结点，又在f层的第m个，于是该数组的长度为2^f - 1 + m + 1个，即2^f + m个，最后一个元素就是父亲结点k，下标为k==2^f + m - 1
            其左孩子结点kL的位置关系，分析可得：
                父亲结点k前面有m个结点，由完全二叉树的定义得到，其左孩子结点kL前面就有2m个结点，进而得到kL位置为f+1层的第2m+1个结点：
                于是计算从根节点到kL结点，包含根节点和kL结点共有多少个结点，即数组的长度：2^(f+1)-1 + 2m + 1,即2^(f+1) + 2m,进而其kL结点的编号下标为2^(f+1) + 2m - 1
            至此，通过比较k和kL的编号下标不难得出：
                kL=2k+1
            进一步，k的右孩子的编号下标为：
                kR=2k+2
            进一步，反过来，从孩子节点编号下标到双亲结点下标为：
                左孩子：k=⌊kL/2⌋
                右孩子：k=⌊kR/2⌋-1
                总结起来：
                k=⌊(kL-1)/2⌋=⌊(kR-1)/2⌋
                即
                k=⌊(孩子下标-1)/2⌋
                    
 
                    
            
