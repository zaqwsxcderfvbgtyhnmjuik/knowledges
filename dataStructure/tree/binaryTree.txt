/// this is a topic about binary tree ///

// 背景
	为何研究二叉树，不研究其他树，是否失去一般性？
        二叉树结构最简单，规律性最强；
        可以证明，所有树都能转为唯一对应的二叉树，不是一般性；同时也可以还原回去；
        普通树(多叉树)，若不转化成为二叉树，则运算很难实现
        所以不失一般性！
        
// 二叉树定义
    是n(n>=0)个结点的有限集，它或者是空集（n==0）,或者由一个根结点及两颗互不相交的分别称为这个根的左子树和右子树的二叉树组成。
    
    特点：
        每个结点至多两个孩子（二叉树中不存在度大于2的结点）
        子树有左右之分，其次序不能颠倒；
            注意: 二叉树不是树的特殊情况，它们是两个概念
	    		二叉树的子树要区分左子树和右子树，即使只有一颗子树也要区分，说明是左子树还是右子树；
				树当结点只有一个孩子时，就无需区分它是左还是右的次序，因此二者是不同的，这是树与二叉树最主要的差别；
			    即二叉树的左右子树与树的有序性的区别；
        二叉树可以是空集，根可以有空的左子树或空的右子树；
        
// 二叉树的五种基本形态
    空二叉树
    根和空的左右子树
    根和左子树
    根和右子树
    根和左右子树
    
// 二叉树性质
    性质1：在二叉树的第i层上至多有2^(i-1)个结点（i>=1）;
        补充：在二叉树的第i层上至少有一个结点，否则该层就不存在了；
    性质2：深度为k的二叉树至多有2^k - 1个结点（k>=1）;
        补充：深度为k的二叉树至少有k个结点（k>=1）;
    性质3：对任何一棵二叉树T,如果叶子结点数为n0,度为2的结点数n2,则n0=n2+1
        证明：
        设总边数为Edges，结点数量为n，
            从下往上看，显而易见除了根节点向上无边后，其余结点均有一个边指向双亲，于是Edges = n-1;
            从上往下看，显而易见度为2的结点向下发出2条边，度为1的结点向下发出1条边，度为0的结点向下发出0条边，于是Edges = n2*2 + n1*1;
            于是得n=n2*2 + n1*1 + 1
            有因为n=n2+n1+n0
            于是有n0 = n2 + 1
        证明完成
        
// 满二叉树
    定义：一个深度为k且有2^k - 1个结点的二叉树。
    特点：
        1.每一层上的结点数都是最大结点数；
        2.叶子结点全部在最底层
        3.对满二叉树从上到下从左至右从1进行编号，每一个编号对应的结点位置都有元素；
        
// 完全二叉树
    定义：深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，称之为完全二叉树。
    特点：
        1.叶子结点可能分布在层次最大的两层上；
        2.对任一结点，如果其右子树的最大层次为i,则其左子树的最大层次必为i或i+1;
        3.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树；
        
// 完全二叉树性质
    性质4：具有n个结点的完全二叉树的深度为⌊log2(n)⌋+1;表明了完全二叉树结点数n与完全二叉树深度k之间的关系。
        注意：⌊x⌋:称作x的底，表示不大于x的最大整数
        证明：假设此完全二叉树的深度为k，则根据二叉树的性质2及完全二叉树的定义能够得到：
            2^(k-1) - 1 < n <=2^k - 1
            放缩后表示为：
            2^(k-1) <= n <2^k
            两边取对数有：
            k-1 <= log2(n) < k
            有因为k是整数，所以有：
            k=⌊log2(n)⌋ + 1
            
    性质5：如果对一棵有n个结点的完全二叉树（深度为⌊log2(n)⌋+1）的结点按层序编号（从第一层到第⌊log2(n)⌋+1层，每层从左到右），则对任一结点i(1<= i <=n)有：
        1) 如果i=1,则结点i是完全二叉树的根，无双亲;如果i>1,则双亲结点是⌊i/2⌋      
        2) 如果2i>n,则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
        3) 如果2i+1>n,则结点i无右孩子；否则，其右孩子是结点2i+1
        证明：结论的编号从1开始，证明从下标编号0开始，实际线性存储时，根节点存储在下标为0的数组开头处：
            进而转换为证明：如果父亲结点的下标为k,则左孩子的下标为2k+1(k=0,1,2,...)
            设父亲结点k为f层第m个(f=0,1,2... ;m=0,1,2...),则k=2^f + m - 1
                思路：
                    数组的长度为L,则最后一个元素的下标为L-1;
                    第0,1,...,f-1层共有2^f - 1个结点，又在f层的第m个，于是该数组的长度为2^f - 1 + m + 1个，即2^f + m个，最后一个元素就是父亲结点k，下标为k==2^f + m - 1
            其左孩子结点kL的位置关系，分析可得：
                父亲结点k前面有m个结点，由完全二叉树的定义得到，其左孩子结点kL前面就有2m个结点，进而得到kL位置为f+1层的第2m+1个结点：
                于是计算从根节点到kL结点，包含根节点和kL结点共有多少个结点，即数组的长度：2^(f+1)-1 + 2m + 1,即2^(f+1) + 2m,进而其kL结点的编号下标为2^(f+1) + 2m - 1
            至此，通过比较k和kL的编号下标不难得出：
                kL=2k+1
            进一步，k的右孩子的编号下标为：
                kR=2k+2
            进一步，反过来，从孩子节点编号下标到双亲结点下标为：
                左孩子：k=⌊kL/2⌋
                右孩子：k=⌊kR/2⌋-1
                总结起来：
                k=⌊(kL-1)/2⌋=⌊(kR-1)/2⌋
                即
                k=⌊(孩子下标-1)/2⌋
                    
 // 二叉树存储结构：结点定义
        顺序存储结构
            实现：按满二叉树的结点层次从上到下从左到右从0开始递增1编号，依次按照编号从小到大从数组下标为0处逐个存放二叉树中的数据元素；
                亲子位次关系，参照性质5
            表示：
                #define MAXSIZE 100
                typedef elemType SqBiTree[MAXSIZE]; //binary tree
                SqBiTree bt;
            分析：
                数组长度固定，对于二叉树元素数量变化较大的情形不适合，适合数量较为稳定的二叉树。（浪费空间）
                数组长度固定，对于稀疏二叉树不适合，适合完全或满二叉树。（浪费空间）
                
        链式存储结构
            二叉链表：
                实现：将一对多的关系进行从前往后地串起来。
                表示：
                    typedef struct BiNode {
                        elemType data;
                        struct BiNode *lchild, *rchild;// 左右孩子指针
                    }BiNode, *BiTree;
            
                分析：
                    一对多的关系从前往后串起来，适合遍历寻找孩子节点情形；
                    在n个结点的二叉链表中，有n+1个空指针区域；
                    证明：
                        n个结点，每个结点两个指针域，则必有2n个指针域；
                        从结点到根反向看，除根节点外，每个结点的前驱都只有一个连线指向双亲，即共有n-1个指针域被使用；
                        未使用的指针域则是空指针域数量：2n - (n - 1)，即n+1个空指针域；
            三叉链表：
                实现：将一对多的关系进行从前往后、从后往前地串起来。
                表示：
                    typedef struct BiNode {
                        elemType data;
                        struct BiNode *lchild, *parent, *rchild;// 左双亲右孩子指针
                    }TriNode, *TriTree;// trinary tree 
            
                分析：
                    一对多的关系从前往后，从后往前串起来，适合往前寻找孩子双亲节点情形；
                    
// 二叉树遍历
    遍历
        定义：
            顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅仅被访问一次（又称周游）。
            注意：
                访问的含义较广，可以是对结点作各种处理，如输出，比较，修改，但要求这种访问不破坏原来的数据结构（不插入、删除结点）；
        目的：
            得到树中所有结点的一个线性排列。
        用途：
            是增删改查和排序运算的前提，是二叉树的一切运算的基础和核心。
            前缀中缀后缀表达式分别对于先序中序后序遍历，可以进行表达式转换操作。
            计算表达式值。
            构建语法树。
            排序树。
            ...
            依据先序中序或后序中序遍历，确定唯一一棵二叉树。
    
    先中后遍历    
        方法：
            依次遍历二叉树的三个组成部分，便是遍历整个二叉树，假设L:遍历左子树，D:遍历根节点，R:遍历右子树，则遍历的方案根据全排列可得6种：DLR,LDR,LRD,DRL,RDL,RLD，
            规定先左后右，则只有前三种情况，见分类。
        
        分类：
            DLR——先（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)访问根结点
                        2)先序遍历左子树
                        3)先序遍历右子树
                算法实现：
                    void preOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        visit(T);
                        preOrderTraverse(T->lchild);
                        preOrderTraverse(T->rchild);
                    }
            LDR——中（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)中序遍历左子树
                        2)访问根结点
                        3)中序遍历右子树
                算法实现：
                    void midOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        midOrderTraverse(T->lchild);
                        visit(T);
                        midOrderTraverse(T->rchild);
                    }
            LRD——后（根）序遍历
                算法描述：
                    若当前(子)二叉树为空，则空操作；
                    否则：
                        1)后序遍历左子树
                        2)后序遍历右子树
                        3)访问根结点
                算法实现：
                    void postOrderTraverse(BiTree T) {
                        if( T==NULL ) return;
                        postOrderTraverse(T->lchild);
                        postOrderTraverse(T->rchild);
                        visit(T);
                    }
        分析：
            如果去掉visit(T)语句，从递归的角度看，三种算法是完全相同的，或者说这三种算法的访问路径是相同的，只是访问结点的时机不同；
            从虚线的出发点到终点的路径上，每个结点经过三次,即执行线与每个结点共同在同一个作用域下3次；（↗↘↖↙）
                第1次经过时访问==先序遍历；不访问时，使用栈记录起该结点；
                第2次经过时访问==中序遍历；不访问时，使用栈记录起该结点；
                第3次经过时访问==后序遍历；不访问时，使用栈记录起该结点；
                           A
                      ↙↗   ↘↖
                    ↙B↖      ↘C↖
                   ↙↗↘↖   ↙↗↘↖

            时间复杂度：O(n) <==> 每个结点访问一次，n个结点访问n次
            空间复杂度：o(n) <==> 最坏情况下，一棵树单侧树，需要记录最多n个结点，所以是O(n)
           
    层次遍历：
        定义：
            对于一棵二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点；每个结点只访问一次。
        算法描述：
            使用一个队列；
            将根结点进队；
            队列不空时循环：从队列中出列一个结点P，访问它；
                若它有左孩子结点，将左孩子结点进队；
                若它有右孩子结点，将右孩子结点进队；
        
        算法实现：
            队列使用std标准库队列queue
            void levelOrderTraverse(BiTree T) {
                std::queue<BiTree> levelQueue;
                levelQueue.push(T); // 将根结点进队
                while( !levelQueue.empty ( ) ) {    // 队列不空时循环：
                    BiTree p = levelQueue.front();  // 从队列中出列一个结点P，访问它
                    visit(p);
                    
                    if (p->lchild) levelQueue.push(p->lchild);  // 有左孩子时将其入队
                    if (p->rchild) levelQueue.push(p->rchild);  // 有右孩子时将其入队
                    levelQueue.pop();   // 可以在front()后面紧接着就调用，pop不会调用pop出来的对象的析构函数，因此紧接着就调用也可以继续使用pop出来的p
                }
            }
                
    遍历运用
        要求：按照先序遍历序列（空节点使用#代替，如ABC##DE#G##F###）建立二叉树的二叉链表。
        算法实现：
            // 主体实现
            void createBiTree(BiTree &T) {
                char ch = '#';
                std::cin>>ch;
                if (ch=='#') T = NULL;
                else {
                    if (T = new BiNode)
                        exit(-1);
                    T->data = ch;
                    createBiTree(T->lchild); // 递归创建左子树 
                    createBiTree(T->rchild);
                }
            }
            
            // 调用逻辑
            BiTree root;
            createBiTree(root);
        
        要求：复制二叉树
	    算法思路：
            如果是空树，算法结束；
            否则
                申请新结点空间，复制根结点
                递归复制左子树
                递归复制右子树
             
        算法实现：
            int CopyBiTree(BiTree T, BiTree &NewT) {
                if ( T==NULL ) {
                    NewT = NULL;
                    return 0;
                }
                else {
                    NewT = new BiTNode();
                    NewT->data = T->data;
                    CopyBiTree( T->lchild, NewT->lchild );
                    CopyBiTree( T->rchild, NewT->rchild );
                }
                
            }
        
        要求：计算二叉树深度
        算法思路：
            如果是空树，则深度为0;
            否则
                递归计算左子树的深度记为m;
                递归计算左子树的深度记为n;
                且二叉树的深度为m和n较大者加1;
        算法实现：
            int Depth(BiTree T) {
                if ( T==NULL ) return 0;
                int m = Depth( T->lchild );
                int n = Depth( T->rchild );
                return max(m, n) + 1;
            }
         
         要求：计算二叉树的结点数
         算法思路：
            如果是空树，则结点个数是0；
            否则
                递归计算左子树的结点个数m；
                递归计算右子树的结点个数n；
                且二叉树的结点个数为m+n后再加1;
         算法实现：
            int nodeCount( BiTree T ) {
                if ( T==NULL ) return 0;
                int m = nodeCount(T->lchild);
                int n = nodeCount(T->rchild);
                return m+n+1;
           }
           
         要求：计算二叉树叶子结点个数
         算法思路：
            如果是空树，则叶子结点个数为0；
            否则
                递归计算左子树的叶子结点数为m;
                递归计算右子树的叶子结点数为n;
                且二叉树的叶子结点数为m+n;

         算法实现：
            int leafNodeCount(BiTree T) {
                if ( T==NULL ) return 0;                            ///< 如果是空树返回0
                if ( T->lchild==NULL && T->rchild==NULL ) return 1; ///< 如果是叶子结点返回1
                int m = leafNodeCount(T->lchild);   ///< T是一棵树，再分别去统计左子树的叶子结点数和右子树的结点数
                int n = leafNodeCount(T->rchild);
                return m+n;
                
            }
           
// 线索二叉树
    提出问题：
        如何寻找二叉链表二叉树特定遍历序列中二叉树结点的前驱和后继？？？
    解决方法：
        1.通过再遍历一次寻找——费时间；
        2.再增设前驱、后继指针域，比如三叉链表——增加了存储的负担
        3.利用二叉链表中的空指针于——√√√
        
    回顾：
        n个结点的二叉链表二叉树中空指针域的数量：n+1个
            证明：
                共n个结点，每个结点2个指针域，所以指针域共有2n个；
                从叶子结点往根结点反向看，除根节点外每个结点都有唯一的一个双亲结点指针域，即全部非空指针域，共有n-1个
                于是空指针域就有Empty = 2n - ( n - 1 ) = n + 1;
            
    定义：
        利用二叉链表二叉树中的空指针域，按照某种遍历序列来确定某个结点在遍历序列中的前驱结点和后继结点，
        如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱结点（由遍历序列确定）；
        如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继结点（由遍历序列确定）；
        若无对应的前驱结点或后继结点，则继续空着（如遍历序列中第一个结点和最后一个结点）。
        ——这种改变指向的指针称为"线索"。
        
        加上了线索的二叉链表二叉树称为"线索二叉树"（threaded binary tree）
        
        对二叉链表二叉树按照某种遍历次序使其变为线索二叉树的过程叫"线索化"。
    
    存储结构：线索二叉树的结点
        为了区分lchild,rchild指针到底是指向孩子的指针，还是指向前驱或后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：
            ltag==0 lchild指向该结点的左孩子
            ltag==1 lchild指向该结点的前驱
            rtag==0 rchild指向该结点的右孩子
            rtag==1 rchild指向该结点的后继
        则表示如下：    
        typedef struct BiThreadedNode {
            elemType data;
            int ltag, rtag; 
            struct BiNode *lchild, *rchild;// 左右孩子指针
        }BiThrNode, *BiThrTree;// Threaded trinary tree 
    
    完善定义：
        根据定义每棵线索二叉树都有 遍历序列中的第一个结点的左指针悬空， 遍历序列中的倒数第一个结点的右指针悬空，为了完善某遍历序列线索二叉链表二叉树的定义，
        增设一个头结点：
            data域为空；
            ltag=0,lchild指向根节点；
            rtag=1,rchild指向遍历序列中倒数第一个结点
        此时，遍历序列中的第一个结点的悬空左指针， 遍历序列中的倒数第一个结点的悬空右指针，都指向头结点；
        同时第一个结点的左指针对应的的ltag置为1，倒数第一个结点的右指针对应的的rtag置为1。
        
    建立
        要求：中序遍历线索二叉链表二叉树线索化
        算法思路：
            第一步：创建二叉树
                先序完整序列建立二叉树
                    空节点使用#表示
                如果是ch==#字符，当前结点置为NULL，并返回
                否则
                    创建新的结点，并进行赋值ch初始化
                    递归创建左子树；
                    递归创建右子树；
                    
            第二步：中序线索化二叉树
                如果是空树，则返回
                否则
                    递归线索化左子树
                    当前结点左指针检测为空，则当前结点左指针指向其前驱结点，若前驱结点为空，指向头结点(算法实现中忽略该步骤)，并置ltag为1；
                        补充：
                            中序遍历，遍历到当前结点时，其前驱结点，必然可当下访问到；
                    前一结点右指针检测为空，则前一结点右指针指向其后继结点，若后继结点为空，指向头结点(算法实现中忽略该步骤)，并置rtag为1；
                        补充：
                            中序遍历，遍历到当前结点时，其后继结点，必然不可当下访问到；因为还没遍历到；于是采用前一结点的右指针为空进行判断，
                                其后继结点必然可当下访问到；
                    当前结点赋值给前一节点;
                    递归线索化右子树
        算法实现：
            // 第一步：先序序列创建二叉树
            void CreateBiTree(BiTree T) {
                // 访问结点
                char ch = '#';
                scanf("%c", &ch);
                if ( ch=='#' ) {
                    T = NULL;
                    return;
                }
                
                T = new BiNode();
                T->data = ch;
                
                // 递归构建左子树
                CreateBiTree(T->lchild);
                
                // 递归构建右子树
                CreateBiTree(T->rchild);
            }
            
            // 第二步：中序线索化
            void midInThread(BiThrTree T, BiThrTree &preT) {
                if ( T==NULL ) return;
                
                midInThread ( T->lchild, preT );
                // 访问操作
                if ( T->lchild==NULL ) { ///< 检测当前结点左指针为空
                    T->lchild = preT;
                    T->ltag   = 1;
                }
                if ( preT!=NULL && preT->rchild==NULL ) { // 检测前一结点的右指针为空
                    preT->rchild = T;
                    preT->rtag   = 1;
                }
                preT = T;
                midInThread ( T->rchild, preT );
                
                }
            同理可以给出前序遍历线索二叉链表二叉树线索化算法实现：
            void preInThread(BiThrTree T, BiThrTree &preT) {
                if ( T==NULL ) return;
                
                // 访问操作
                if ( T->lchild==NULL ) { ///< 检测当前结点左指针为空
                    T->lchild = preT;
                    T->ltag   = 1;
                }
                if ( preT!=NULL && preT->rchild==NULL ) { ///< 检测前一结点的右指针为空
                    preT->rchild = T;
                    preT->rtag   = 1;
                }
                preT = T;
                
                if ( T->ltag==0 ) ///< 这里因为T->lchild进行判断决定是否继续递归，否则进入死循环
                    preInThread ( T->lchild, preT );
                if ( T->rtag==0 )
                    preInThread ( T->rchild, preT );
                }
           同理可以给出后序遍历线索二叉链表二叉树线索化算法实现：
            void postInThread(BiThrTree T, BiThrTree &preT) {
                if ( T==NULL ) return;
                
                if ( T->ltag==0 ) ///< 因为这里的T->lchild可能是T的前驱结点，如果不判断ltag，则会死循环
                    postInThread ( T->lchild, preT );
                if ( T->rtag==0 ) 
                    postInThread ( T->rchild, preT );
                    
                 // 访问操作
                if ( T->lchild==NULL ) { ///< 检测当前结点左指针为空
                    T->lchild = preT;
                    T->ltag   = 1;
                }
                if ( preT!=NULL && preT->rchild==NULL ) { ///< 检测前一结点的右指针为空
                    preT->rchild = T;
                    preT->rtag   = 1;
                }
                preT = T;
                
                }
    遍历：  
        要求：中序线索二叉树遍历
        算法思路：
            如果是空树，则返回
            否则：
                访问当前树的最左下结点，中序序列中排第一个的元素，其前驱是NULL，并访问该结点
                当当前结点标志位为1，且后继结点不为NULL时，直接找其后继结点，并进行访问，直到线索消失或后继结点为NULL
                否则，按照中序遍历规律，找其右子树的最左下结点，也就是继续循环遍历
                
        算法实现：
            void midOrderThrTraverse( BiThrTree T ) {
                while ( T ) {
                    // 一直找左孩子，最后一个左孩子为中序序列中排第一个的元素，其前驱是NULL
                    while ( T->ltag==0)
                        T = T->lchild;
                    
                    // 访问结点 
                    printf("%c", T->data);
                    
                    // 当结点标志位为1，且后继结点不为NULL时，直接找其后继结点
                    while ( T->rtag==1 && T->rchild!=NULL) {
                        T = T->rchild;
                        printf("%c", T->data);// 访问结点 
                    }
                    
                    // 否则，按照中序遍历规律，找其右子树的最左下结点，也就是继续循环遍历
                    T = T->rchild;
                }
            }
           
    分析：
        利用建立的线索二叉树找某个结点的前驱或后继，仍不能有效解决先序线索二叉树找先序前驱、后序线索二叉树找后序后继，综合后中序线索二叉树效果最好（不全是100%的效果）。
        线索化后的二叉树，遍历时比未进行线索化的树效率高：
            未线索化的遍历若采用递归，那么每一个元素都是递归调用一次函数后遍历出来；线索化的二叉树则可以不进行递归调用，而逐一按照某序顺序遍历出所有元素。
    
        
           
           
           
           
           
           
           
           
           
            
