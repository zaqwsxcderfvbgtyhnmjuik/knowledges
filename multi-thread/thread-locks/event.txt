/// this is a topic about event ///

// 来源
  
// 原理

// 作用

// 使用注意事项


// event implementation
  // header
  class CAutoEvent : public INoncopyable {
  public:
    CAutoEvent (){}
    ~CAutoEvent (){}
    
    bool Init ( CMutex *pMutex );
    bool Done ();
    void SetEvent ();
    void WaitEvent ();
  
  protected:
    bool m_bInitialized;
    bool m_bSent;
    
  #if USE_WINDOWS
    HANDLE m_hEvent;
  #else
    pthread_cond_t m_tCond;
    pthread_mutex_t *m_pMutex;
  #endif
  };
  
  // source
  // windows event implementation
  #if USE_WINDOWS
  bool CAutoEvent::Init ( CMutex * ) {
    m_bSent = false;
    m_hEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
    m_bInitialized = ( m_hEvent!=NULL );
    return m_bInitialized;
    }
    
  bool CAutoEvent::Done () {
    if ( !m_bInitialized )
        return true;
    
    m_bInitialized = false;
    return ::CloseHandle ( m_hEvent )==TRUE;
    }
    
  void CAutoEvent () {
    ::SetEvent ( m_hEvent );
    m_bSent = true;
    }
    
  bool CAutoEvent () {
    if ( m_bSent ) {
        m_bSent = false;
        return true;
    }
    
    DWORD uWait = ::WaitForSingleObject ( m_hEvent, INFINITE );
    return ( uWait==WAIT_FAILED || uWait==WAIT_TIMEOUT );
    }
        
  #else
  
  // UNIX Event implementation
  bool CAutoEvent::Init ( CMutex *pMutex ) {
    m_bSent = false;
    assert ( pMutex );
    if ( !pMutex )
        return false;
    
    m_pMutex = pMutex->GetInternalMutex ();
    m_bInitialized = ( pthread_cond_init ( &m_tCond, NULL )==0 );
    return m_bInitialized;
    }
    
  bool CAutoEvent::Done () {
    if ( !m_bInitialized )
        return true;
    
    m_bInitialized = false;
    return ( pthread_cond_destroy ( &m_tCond ) )==0;
    }
  
  void CAutoEvent::SetEvent () {
    if ( !m_bInitialized )
        return;
    
    pthread_cond_signal ( &m_tCond ); // locking is done from outside
    m_bSent = true;
    }
    
  bool CAutoEvent::WaitEvent () {
    if ( !m_bInitialized )
        return;
    
    pthread_mutex_lock ( m_pMutex );
    if ( !m_bSent )
        pthread_cond_wait ( &m_tCond, m_pMutex );
    m_bSent = false;
    pthread_mutex_unlock ( m_pMutex );
    return true;
    }
  #endif
    
  
