/********a topic about how many one bits in a 32bit unsigned int number **********/

// 1 look at the follwing function, then to think what is it the detail process
    inline int bitCount ( unsigned int n )
    {
      // MIT HACKMEM count
      // works for 32-bit numbers only
      // fix last line for 64-bit numbers
      register unsigned int tmp;
      tmp = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111);
      return ( (tmp + (tmp >> 3) ) & 030707070707) % 63;
    }

// 2 basic thery listed here
    A.移位运算符
      a. 右移移位运算符>>的使用
        无符号数使用>>时，高位填充0
        有符号数正数使用>>时，高位填充0，同无符号数一样
        有符号数负数使用>>时，高位填充1，具体为何填充1，与负数的补码机制相关

      b.左移运算符<<的使用
        有符号/符号数使用<<时，低位填充0
        
      c.无符号右移>>>运算符使用
        若该数为正，则高位补0；若该数为负，则高位补0；又称之为逻辑右移。
    
    B.位操作符：不管是正数还是负数，都是用各自的补码按位操作，操作的结果可以使用有符号、无符号正数来进行存储，将发生一次重新解释，即reinterpret_cast效果一样，内存01状态不变，重新对原有的01赋予新的解释
      a.按位或运算符|
        将两数的补码进行按位或
      b.按位或运算符&
        将两数的补码进行按位与
      c.按位或运算符~
        将两数的补码进行按位取反
      d.按位或运算符^
        将两数的补码进行按位异或
    
    C.无符号二进制数的多种表示：有符号的只需在前面加符号位即可，0表示正数，1表示负数
      a.二进制表示
        1111 1111
        对应十进制值：1*2^(7) + 1*2^(6) + 1*2^(5) + 1*2^(4) + 1*2^(3) + 1*2^(2) + 1*2^(1) + 1*2^(0) = 255
      b.四进制表示
        33 33
        对应十进制值：3*4^(3) + 3*4^(2) + 3*4^(1) + 3*4^(0) = 255
      c.八进制表示
        0377
        对应十进制值：3*8^(2) + 7*8^(1) + 7*8^(0) = 255
      d.十六进制表示
        0xFF
        对应十进制值：F*16^(1) + F*16^(0) = 255
      e.三十二进制表示
        7(31)
        对应十进制值：7*32^(1) + 31*32^(0) = 255
      f.六十四进制表示
        3(63)
        对应十进制值：3*64^(1) + 63*64^(0) = 255
      g.总结
        可以将二进制的一位、两位、三位、四位...看成进制的基底2、4、8、16、32、64...，就是对应进制的新数
    
    D.n进制数按位展开系数与取余数关系原理
      若按位展开系数之和不超过进制数n，则对n - 1取余的结果为按位展开系数和
      例如64进制数按位展开式为1*64^2 + 2*64^1 + 3*64^0对64 - 1取余有(1*64^2 + 2*64^1 + 3*64^0)%63 
        = (3*64) % 63 + (2*64^1)%63 + (1*64^2)%63 
        = 3 + [2*(63 + 1)] % 63 + [1*64*(63 + 1)]%63
        = 3 + 2 + [1*64]%63
        = 3 + 2 + [1*(63+1)]%63
        = 3 + 2 + 1 
        = 6
// 3 basic steps for understanding the bitCount function
    a.第一部分，看一个小例子，对于3位二进制
      如5=101，查看三位的二进制数5有几位bit，将5用二进制表示成abc，那么1的个数就是a+b+c；
      又知5=4a+2b+c
      那么(5>>1)&(03)=2a+b；
        此处为什么要按位与上(03)，是为了防止高位不填充0造成影响，什么时候右移会高位不填充0呢？
        多个3位的二进制先后形成一个二进制串时，右移一位，对于该二进制串的最右端一定是填充0，
        对于起点不是最右端的3位二进制串，右移一位时，最高位会接收上一个三位二进制串丢弃的最低位为最高位，
        于是对于当前的三位二进制串的最高位可能没有填充0，取决于上一个三位二进制串丢弃的最低位，
        于是需要按位与03，消除最高位可能不是0的影响，确保每个三位串右移时最高位填充0。
      同理，(5>>2)&(01)=a
      所以可得：5 - (5>>1)&(03) - (5>>2)&(01) = a + b + c
      对于三位二进制串来讲，此时结果是当前三位二进制串中1的个数；
      对于32位的二进制串来讲，可以分为11组，每组3位，第一组是2位
      所以n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111)所得的结果就是每三位中1的个数所组成的32位数；
        将每三位看成一个基数，那么等价于n11*8^10 + n10*8^9 + n9*8^8 + n8*8^7 + n7*8^6 + n6*8^5 + n5*8^4 + n4*8^3 + n3*8^2 + n2*8^1 + n1*8^0数，
        该32位无符号正数中包含的1的个数为n11 + n10 + n9 + n8 + n7 + n7 + n6 + n5 + n4 + n3 + n2 + n1，那么如何取出来呢？
    b.第二部分，如何得到n11 + n10 + ... + n1结果呢？
      我们知道对于32位无符号整数，至多包含32个1，至少包含0个1，于是0 <= n11 + n10 + ... + n1 <=32；且原因为 0<= ni <=3 (i = 1,2,...,10)，0<= n11 <=2
      再根据D的理论进行分析可得，想要利用D理论，但是条件不满足，为了满足条件，将第一部分得到的结果进行进制上升处理，同时保持语义不丢失
      即(tmp + (tmp >> 3)，将第一部分的中间结果tmp右移3位后和tmp自身相加，即
        n11*8^10 + n10*8^9 + n9*8^8 + n8*8^7 + n7*8^6 + n6*8^5 + n5*8^4 + n4*8^3 + n3*8^2 + n2*8^1 + n1*8^0
       +
                   n11*8^9 + n10*8^8 + n9*8^7 + n8*8^6 + n7*8^5 + n6*8^4 + n5*8^3 + n4*8^2 + n3*8^1 + n2*8^0
       =n11*8^10 + (n11 + n10)*8^9 + (n10 + n9)*8^8 + (n9 + n8)*8^7 + (n8 + n7)*8^6 + (n7 + n6)*8^5 + (n6 + n5)*8^4 + (n5 + n4)*8^3 + (n4 + n3)*8^2 + (n3 + n2)*8^1 + (n2 + n1)*8^0
       此时经过观察得到，从右向左只需要将8进制的偶数下标的数字加起来，就是原来的tmp
       又因为ni + ni-1 <= 6，对于此时的8进制未产生进位感染
       于是将奇数下标的8进制的项根据二进制的不同表示与前面的偶数下标的八进制项进行合并，合并成64进制的数，合并的操作是将奇数下标的八进制的项消除掉，成为000做为64进制的高位，于是有了如下操作
       (tmp + (tmp >> 3) ) & 030707070707)
       根据该操作可得n11*64^5 + (n10 + n9)*64^4 + (n8 + n7)*64^3 + (n6 + n5)*64^2 + (n4 + n3)*64^1 + (n2 + n1)*64^0
       此时满足D原理的条件，n11 + n10 + ... + n1 < 64，于是根据原理D可得如下操作
       (tmp + (tmp >> 3) ) & 030707070707)%63
       就是32位无符号整数中含有的为1的bit数量
        
